{
  "version": 3,
  "sources": ["../../event.ts", "../../utils.ts", "../../filter.ts", "../../fakejson.ts", "../../relay.ts"],
  "sourcesContent": ["import { schnorr } from '@noble/curves/secp256k1'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nimport { getPublicKey } from './keys.ts'\nimport { utf8Encoder } from './utils.ts'\n\n/** Designates a verified event signature. */\nexport const verifiedSymbol = Symbol('verified')\n\n/** @deprecated Use numbers instead. */\n/* eslint-disable no-unused-vars */\nexport enum Kind {\n  Metadata = 0,\n  Text = 1,\n  RecommendRelay = 2,\n  Contacts = 3,\n  EncryptedDirectMessage = 4,\n  EventDeletion = 5,\n  Repost = 6,\n  Reaction = 7,\n  BadgeAward = 8,\n  ChannelCreation = 40,\n  ChannelMetadata = 41,\n  ChannelMessage = 42,\n  ChannelHideMessage = 43,\n  ChannelMuteUser = 44,\n  Blank = 255,\n  Report = 1984,\n  ZapRequest = 9734,\n  Zap = 9735,\n  RelayList = 10002,\n  ClientAuth = 22242,\n  NwcRequest = 23194,\n  HttpAuth = 27235,\n  ProfileBadge = 30008,\n  BadgeDefinition = 30009,\n  Article = 30023,\n  FileMetadata = 1063,\n}\n\nexport interface Event<K extends number = number> {\n  kind: K\n  tags: string[][]\n  content: string\n  created_at: number\n  pubkey: string\n  id: string\n  sig: string\n  [verifiedSymbol]?: boolean\n}\n\nexport type EventTemplate<K extends number = number> = Pick<Event<K>, 'kind' | 'tags' | 'content' | 'created_at'>\nexport type UnsignedEvent<K extends number = number> = Pick<\n  Event<K>,\n  'kind' | 'tags' | 'content' | 'created_at' | 'pubkey'\n>\n\n/** An event whose signature has been verified. */\nexport interface VerifiedEvent<K extends number = number> extends Event<K> {\n  [verifiedSymbol]: true\n}\n\nexport function getBlankEvent(): EventTemplate<Kind.Blank>\nexport function getBlankEvent<K extends number>(kind: K): EventTemplate<K>\nexport function getBlankEvent<K>(kind: K | Kind.Blank = Kind.Blank) {\n  return {\n    kind,\n    content: '',\n    tags: [],\n    created_at: 0,\n  }\n}\n\nexport function finishEvent<K extends number = number>(t: EventTemplate<K>, privateKey: string): VerifiedEvent<K> {\n  const event = t as VerifiedEvent<K>\n  event.pubkey = getPublicKey(privateKey)\n  event.id = getEventHash(event)\n  event.sig = getSignature(event, privateKey)\n  event[verifiedSymbol] = true\n  return event\n}\n\nexport function serializeEvent(evt: UnsignedEvent<number>): string {\n  if (!validateEvent(evt)) throw new Error(\"can't serialize event with wrong or missing properties\")\n\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])\n}\n\nexport function getEventHash(event: UnsignedEvent<number>): string {\n  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)))\n  return bytesToHex(eventHash)\n}\n\nconst isRecord = (obj: unknown): obj is Record<string, unknown> => obj instanceof Object\n\nexport function validateEvent<T>(event: T): event is T & UnsignedEvent<number> {\n  if (!isRecord(event)) return false\n  if (typeof event.kind !== 'number') return false\n  if (typeof event.content !== 'string') return false\n  if (typeof event.created_at !== 'number') return false\n  if (typeof event.pubkey !== 'string') return false\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false\n\n  if (!Array.isArray(event.tags)) return false\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i]\n    if (!Array.isArray(tag)) return false\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === 'object') return false\n    }\n  }\n\n  return true\n}\n\n/** Verify the event's signature. This function mutates the event with a `verified` symbol, making it idempotent. */\nexport function verifySignature<K extends number>(event: Event<K>): event is VerifiedEvent<K> {\n  if (typeof event[verifiedSymbol] === 'boolean') return event[verifiedSymbol]\n\n  const hash = getEventHash(event)\n  if (hash !== event.id) {\n    return (event[verifiedSymbol] = false)\n  }\n\n  try {\n    return (event[verifiedSymbol] = schnorr.verify(event.sig, hash, event.pubkey))\n  } catch (err) {\n    return (event[verifiedSymbol] = false)\n  }\n}\n\n/** @deprecated Use `getSignature` instead. */\nexport function signEvent(event: UnsignedEvent<number>, key: string): string {\n  console.warn(\n    'nostr-tools: `signEvent` is deprecated and will be removed or changed in the future. Please use `getSignature` instead.',\n  )\n  return getSignature(event, key)\n}\n\n/** Calculate the signature for an event. */\nexport function getSignature(event: UnsignedEvent<number>, key: string): string {\n  return bytesToHex(schnorr.sign(getEventHash(event), key))\n}\n", "import type { Event } from './event.ts'\n\nexport const utf8Decoder = new TextDecoder('utf-8')\nexport const utf8Encoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\n//\n// fast insert-into-sorted-array functions adapted from https://github.com/terrymorse58/fast-sorted-array\n//\nexport function insertEventIntoDescendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport class MessageNode {\n  private _value: string\n  private _next: MessageNode | null\n\n  public get value(): string {\n    return this._value\n  }\n  public set value(message: string) {\n    this._value = message\n  }\n  public get next(): MessageNode | null {\n    return this._next\n  }\n  public set next(node: MessageNode | null) {\n    this._next = node\n  }\n\n  constructor(message: string) {\n    this._value = message\n    this._next = null\n  }\n}\n\nexport class MessageQueue {\n  private _first: MessageNode | null\n  private _last: MessageNode | null\n\n  public get first(): MessageNode | null {\n    return this._first\n  }\n  public set first(messageNode: MessageNode | null) {\n    this._first = messageNode\n  }\n  public get last(): MessageNode | null {\n    return this._last\n  }\n  public set last(messageNode: MessageNode | null) {\n    this._last = messageNode\n  }\n  private _size: number\n  public get size(): number {\n    return this._size\n  }\n  public set size(v: number) {\n    this._size = v\n  }\n\n  constructor() {\n    this._first = null\n    this._last = null\n    this._size = 0\n  }\n  enqueue(message: string): boolean {\n    const newNode = new MessageNode(message)\n    if (this._size === 0 || !this._last) {\n      this._first = newNode\n      this._last = newNode\n    } else {\n      this._last.next = newNode\n      this._last = newNode\n    }\n    this._size++\n    return true\n  }\n  dequeue(): string | null {\n    if (this._size === 0 || !this._first) return null\n\n    let prev = this._first\n    this._first = prev.next\n    prev.next = null\n\n    this._size--\n    return prev.value\n  }\n}\n", "import { Event } from './event.ts'\n\nexport type Filter<K extends number = number> = {\n  ids?: string[]\n  kinds?: K[]\n  authors?: string[]\n  since?: number\n  until?: number\n  limit?: number\n  search?: string\n  [key: `#${string}`]: string[] | undefined\n}\n\nexport function matchFilter(filter: Filter<number>, event: Event<number>): boolean {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    if (!filter.ids.some(prefix => event.id.startsWith(prefix))) {\n      return false\n    }\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    if (!filter.authors.some(prefix => event.pubkey.startsWith(prefix))) {\n      return false\n    }\n  }\n\n  for (let f in filter) {\n    if (f[0] === '#') {\n      let tagName = f.slice(1)\n      let values = filter[`#${tagName}`]\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values!.indexOf(v) !== -1)) return false\n    }\n  }\n\n  if (filter.since && event.created_at < filter.since) return false\n  if (filter.until && event.created_at > filter.until) return false\n\n  return true\n}\n\nexport function matchFilters(filters: Filter<number>[], event: Event<number>): boolean {\n  for (let i = 0; i < filters.length; i++) {\n    if (matchFilter(filters[i], event)) return true\n  }\n  return false\n}\n\nexport function mergeFilters(...filters: Filter<number>[]): Filter<number> {\n  let result: Filter<number> = {}\n  for (let i = 0; i < filters.length; i++) {\n    let filter = filters[i]\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === 'kinds' || property === 'ids' || property === 'authors' || property[0] === '#') {\n        // @ts-ignore\n        result[property] = result[property] || []\n        // @ts-ignore\n        for (let v = 0; v < values.length; v++) {\n          // @ts-ignore\n          let value = values[v]\n          // @ts-ignore\n          if (!result[property].includes(value)) result[property].push(value)\n        }\n      }\n    })\n\n    if (filter.limit && (!result.limit || filter.limit > result.limit)) result.limit = filter.limit\n    if (filter.until && (!result.until || filter.until > result.until)) result.until = filter.until\n    if (filter.since && (!result.since || filter.since < result.since)) result.since = filter.since\n  }\n\n  return result\n}\n", "export function getHex64(json: string, field: string): string {\n  let len = field.length + 3\n  let idx = json.indexOf(`\"${field}\":`) + len\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1\n  return json.slice(s, s + 64)\n}\n\nexport function getInt(json: string, field: string): number {\n  let len = field.length\n  let idx = json.indexOf(`\"${field}\":`) + len + 3\n  let sliced = json.slice(idx)\n  let end = Math.min(sliced.indexOf(','), sliced.indexOf('}'))\n  return parseInt(sliced.slice(0, end), 10)\n}\n\nexport function getSubscriptionId(json: string): string | null {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`)\n  if (idx === -1) return null\n\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`)\n  if (pstart === -1) return null\n  let start = idx + 7 + 1 + pstart\n\n  let pend = json.slice(start + 1, 80).indexOf(`\"`)\n  if (pend === -1) return null\n  let end = start + 1 + pend\n\n  return json.slice(start + 1, end)\n}\n\nexport function matchEventId(json: string, id: string): boolean {\n  return id === getHex64(json, 'id')\n}\n\nexport function matchEventPubkey(json: string, pubkey: string): boolean {\n  return pubkey === getHex64(json, 'pubkey')\n}\n\nexport function matchEventKind(json: string, kind: number): boolean {\n  return kind === getInt(json, 'kind')\n}\n", "/* global WebSocket */\n\nimport { verifySignature, validateEvent, type Event } from './event.ts'\nimport { matchFilters, type Filter } from './filter.ts'\nimport { getHex64, getSubscriptionId } from './fakejson.ts'\nimport { MessageQueue } from './utils.ts'\n\ntype RelayEvent = {\n  connect: () => void | Promise<void>\n  disconnect: () => void | Promise<void>\n  error: () => void | Promise<void>\n  notice: (msg: string) => void | Promise<void>\n  auth: (challenge: string) => void | Promise<void>\n}\nexport type CountPayload = {\n  count: number\n}\nexport type SubEvent<K extends number> = {\n  event: (event: Event<K>) => void | Promise<void>\n  count: (payload: CountPayload) => void | Promise<void>\n  eose: () => void | Promise<void>\n}\nexport type Relay = {\n  url: string\n  status: number\n  connect: () => Promise<void>\n  close: () => void\n  sub: <K extends number = number>(filters: Filter<K>[], opts?: SubscriptionOptions) => Sub<K>\n  list: <K extends number = number>(filters: Filter<K>[], opts?: SubscriptionOptions) => Promise<Event<K>[]>\n  get: <K extends number = number>(filter: Filter<K>, opts?: SubscriptionOptions) => Promise<Event<K> | null>\n  count: (filters: Filter[], opts?: SubscriptionOptions) => Promise<CountPayload | null>\n  publish: (event: Event<number>) => Promise<void>\n  auth: (event: Event<number>) => Promise<void>\n  off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(event: T, listener: U) => void\n  on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(event: T, listener: U) => void\n}\nexport type Sub<K extends number = number> = {\n  sub: <K extends number = number>(filters: Filter<K>[], opts: SubscriptionOptions) => Sub<K>\n  unsub: () => void\n  on: <T extends keyof SubEvent<K>, U extends SubEvent<K>[T]>(event: T, listener: U) => void\n  off: <T extends keyof SubEvent<K>, U extends SubEvent<K>[T]>(event: T, listener: U) => void\n  events: AsyncGenerator<Event<K>, void, unknown>\n}\n\nexport type SubscriptionOptions = {\n  id?: string\n  verb?: 'REQ' | 'COUNT'\n  skipVerification?: boolean\n  alreadyHaveEvent?: null | ((id: string, relay: string) => boolean)\n  eoseSubTimeout?: number\n}\n\nconst newListeners = (): { [TK in keyof RelayEvent]: RelayEvent[TK][] } => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: [],\n})\n\nexport function relayInit(\n  url: string,\n  options: {\n    getTimeout?: number\n    listTimeout?: number\n    countTimeout?: number\n  } = {},\n): Relay {\n  let { listTimeout = 3000, getTimeout = 3000, countTimeout = 3000 } = options\n\n  var ws: WebSocket\n  var openSubs: { [id: string]: { filters: Filter[] } & SubscriptionOptions } = {}\n  var listeners = newListeners()\n  var subListeners: {\n    [subid: string]: { [TK in keyof SubEvent<any>]: SubEvent<any>[TK][] }\n  } = {}\n  var pubListeners: {\n    [eventid: string]: {\n      resolve: (_: unknown) => void\n      reject: (err: Error) => void\n    }\n  } = {}\n\n  var connectionPromise: Promise<void> | undefined\n  async function connectRelay(): Promise<void> {\n    if (connectionPromise) return connectionPromise\n    connectionPromise = new Promise((resolve, reject) => {\n      try {\n        ws = new WebSocket(url)\n      } catch (err) {\n        reject(err)\n      }\n\n      ws.onopen = () => {\n        listeners.connect.forEach(cb => cb())\n        resolve()\n      }\n      ws.onerror = () => {\n        connectionPromise = undefined\n        listeners.error.forEach(cb => cb())\n        reject()\n      }\n      ws.onclose = async () => {\n        connectionPromise = undefined\n        listeners.disconnect.forEach(cb => cb())\n      }\n\n      let incomingMessageQueue: MessageQueue = new MessageQueue()\n      let handleNextInterval: any\n\n      ws.onmessage = e => {\n        incomingMessageQueue.enqueue(e.data)\n        if (!handleNextInterval) {\n          handleNextInterval = setInterval(handleNext, 0)\n        }\n      }\n\n      function handleNext() {\n        if (incomingMessageQueue.size === 0) {\n          clearInterval(handleNextInterval)\n          handleNextInterval = null\n          return\n        }\n\n        var json = incomingMessageQueue.dequeue()\n        if (!json) return\n\n        let subid = getSubscriptionId(json)\n        if (subid) {\n          let so = openSubs[subid]\n          if (so && so.alreadyHaveEvent && so.alreadyHaveEvent(getHex64(json, 'id'), url)) {\n            return\n          }\n        }\n\n        try {\n          let data = JSON.parse(json)\n\n          // we won't do any checks against the data since all failures (i.e. invalid messages from relays)\n          // will naturally be caught by the encompassing try..catch block\n\n          switch (data[0]) {\n            case 'EVENT': {\n              let id = data[1]\n              let event = data[2]\n              if (\n                validateEvent(event) &&\n                openSubs[id] &&\n                (openSubs[id].skipVerification || verifySignature(event)) &&\n                matchFilters(openSubs[id].filters, event)\n              ) {\n                openSubs[id]\n                ;(subListeners[id]?.event || []).forEach(cb => cb(event))\n              }\n              return\n            }\n            case 'COUNT':\n              let id = data[1]\n              let payload = data[2]\n              if (openSubs[id]) {\n                ;(subListeners[id]?.count || []).forEach(cb => cb(payload))\n              }\n              return\n            case 'EOSE': {\n              let id = data[1]\n              if (id in subListeners) {\n                subListeners[id].eose.forEach(cb => cb())\n                subListeners[id].eose = [] // 'eose' only happens once per sub, so stop listeners here\n              }\n              return\n            }\n            case 'OK': {\n              let id: string = data[1]\n              let ok: boolean = data[2]\n              let reason: string = data[3] || ''\n              if (id in pubListeners) {\n                let { resolve, reject } = pubListeners[id]\n                if (ok) resolve(null)\n                else reject(new Error(reason))\n              }\n              return\n            }\n            case 'NOTICE':\n              let notice = data[1]\n              listeners.notice.forEach(cb => cb(notice))\n              return\n            case 'AUTH': {\n              let challenge = data[1]\n              listeners.auth?.forEach(cb => cb(challenge))\n              return\n            }\n          }\n        } catch (err) {\n          return\n        }\n      }\n    })\n\n    return connectionPromise\n  }\n\n  function connected() {\n    return ws?.readyState === 1\n  }\n\n  async function connect(): Promise<void> {\n    if (connected()) return // ws already open\n    await connectRelay()\n  }\n\n  async function trySend(params: [string, ...any]) {\n    let msg = JSON.stringify(params)\n    if (!connected()) {\n      await new Promise(resolve => setTimeout(resolve, 1000))\n      if (!connected()) {\n        return\n      }\n    }\n    try {\n      ws.send(msg)\n    } catch (err) {\n      console.log(err)\n    }\n  }\n\n  const sub = <K extends number = number>(\n    filters: Filter<K>[],\n    {\n      verb = 'REQ',\n      skipVerification = false,\n      alreadyHaveEvent = null,\n      id = Math.random().toString().slice(2),\n    }: SubscriptionOptions = {},\n  ): Sub<K> => {\n    let subid = id\n\n    openSubs[subid] = {\n      id: subid,\n      filters,\n      skipVerification,\n      alreadyHaveEvent,\n    }\n    trySend([verb, subid, ...filters])\n\n    let subscription: Sub<K> = {\n      sub: (newFilters, newOpts = {}) =>\n        sub(newFilters || filters, {\n          skipVerification: newOpts.skipVerification || skipVerification,\n          alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,\n          id: subid,\n        }),\n      unsub: () => {\n        delete openSubs[subid]\n        delete subListeners[subid]\n        trySend(['CLOSE', subid])\n      },\n      on: (type, cb) => {\n        subListeners[subid] = subListeners[subid] || {\n          event: [],\n          count: [],\n          eose: [],\n        }\n        subListeners[subid][type].push(cb)\n      },\n      off: (type, cb): void => {\n        let listeners = subListeners[subid]\n        let idx = listeners[type].indexOf(cb)\n        if (idx >= 0) listeners[type].splice(idx, 1)\n      },\n      get events() {\n        return eventsGenerator(subscription)\n      },\n    }\n\n    return subscription\n  }\n\n  function _publishEvent(event: Event<number>, type: string) {\n    return new Promise((resolve, reject) => {\n      if (!event.id) {\n        reject(new Error(`event ${event} has no id`))\n        return\n      }\n\n      let id = event.id\n      trySend([type, event])\n      pubListeners[id] = { resolve, reject }\n    })\n  }\n\n  return {\n    url,\n    sub,\n    on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(type: T, cb: U): void => {\n      listeners[type].push(cb)\n      if (type === 'connect' && ws?.readyState === 1) {\n        // i would love to know why we need this\n        ;(cb as () => void)()\n      }\n    },\n    off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(type: T, cb: U): void => {\n      let index = listeners[type].indexOf(cb)\n      if (index !== -1) listeners[type].splice(index, 1)\n    },\n    list: (filters, opts?: SubscriptionOptions) =>\n      new Promise(resolve => {\n        let s = sub(filters, opts)\n        let events: Event<any>[] = []\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(events)\n        }, listTimeout)\n        s.on('eose', () => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(events)\n        })\n        s.on('event', event => {\n          events.push(event)\n        })\n      }),\n    get: (filter, opts?: SubscriptionOptions) =>\n      new Promise(resolve => {\n        let s = sub([filter], opts)\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, getTimeout)\n        s.on('event', event => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    count: (filters: Filter[]): Promise<CountPayload | null> =>\n      new Promise(resolve => {\n        let s = sub(filters, { ...sub, verb: 'COUNT' })\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, countTimeout)\n        s.on('count', (event: CountPayload) => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    async publish(event): Promise<void> {\n      await _publishEvent(event, 'EVENT')\n    },\n    async auth(event): Promise<void> {\n      await _publishEvent(event, 'AUTH')\n    },\n    connect,\n    close(): void {\n      listeners = newListeners()\n      subListeners = {}\n      pubListeners = {}\n      if (ws?.readyState === WebSocket.OPEN) {\n        ws.close()\n      }\n    },\n    get status() {\n      return ws?.readyState ?? 3\n    },\n  }\n}\n\nexport async function* eventsGenerator<K extends number>(sub: Sub<K>): AsyncGenerator<Event<K>, void, unknown> {\n  let nextResolve: ((event: Event<K>) => void) | undefined\n  const eventQueue: Event<K>[] = []\n\n  const pushToQueue = (event: Event<K>) => {\n    if (nextResolve) {\n      nextResolve(event)\n      nextResolve = undefined\n    } else {\n      eventQueue.push(event)\n    }\n  }\n\n  sub.on('event', pushToQueue)\n\n  try {\n    while (true) {\n      if (eventQueue.length > 0) {\n        yield eventQueue.shift()!\n      } else {\n        const event = await new Promise<Event<K>>(resolve => {\n          nextResolve = resolve\n        })\n        yield event\n      }\n    }\n  } finally {\n    sub.off('event', pushToQueue)\n  }\n}\n"],
  "mappings": ";AAAA,SAAS,eAAe;AACxB,SAAS,cAAc;AACvB,SAAS,kBAAkB;;;ACApB,IAAM,cAAc,IAAI,YAAY,OAAO;AAC3C,IAAM,cAAc,IAAI,YAAY;AA2FpC,IAAM,cAAN,MAAkB;AAAA,EACf;AAAA,EACA;AAAA,EAER,IAAW,QAAgB;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAW,MAAM,SAAiB;AAChC,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,IAAW,OAA2B;AACpC,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAW,KAAK,MAA0B;AACxC,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,YAAY,SAAiB;AAC3B,SAAK,SAAS;AACd,SAAK,QAAQ;AAAA,EACf;AACF;AAEO,IAAM,eAAN,MAAmB;AAAA,EAChB;AAAA,EACA;AAAA,EAER,IAAW,QAA4B;AACrC,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAW,MAAM,aAAiC;AAChD,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,IAAW,OAA2B;AACpC,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAW,KAAK,aAAiC;AAC/C,SAAK,QAAQ;AAAA,EACf;AAAA,EACQ;AAAA,EACR,IAAW,OAAe;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAW,KAAK,GAAW;AACzB,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,cAAc;AACZ,SAAK,SAAS;AACd,SAAK,QAAQ;AACb,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,QAAQ,SAA0B;AAChC,UAAM,UAAU,IAAI,YAAY,OAAO;AACvC,QAAI,KAAK,UAAU,KAAK,CAAC,KAAK,OAAO;AACnC,WAAK,SAAS;AACd,WAAK,QAAQ;AAAA,IACf,OAAO;AACL,WAAK,MAAM,OAAO;AAClB,WAAK,QAAQ;AAAA,IACf;AACA,SAAK;AACL,WAAO;AAAA,EACT;AAAA,EACA,UAAyB;AACvB,QAAI,KAAK,UAAU,KAAK,CAAC,KAAK;AAAQ,aAAO;AAE7C,QAAI,OAAO,KAAK;AAChB,SAAK,SAAS,KAAK;AACnB,SAAK,OAAO;AAEZ,SAAK;AACL,WAAO,KAAK;AAAA,EACd;AACF;;;ADhKO,IAAM,iBAAiB,OAAO,UAAU;AA2ExC,SAAS,eAAe,KAAoC;AACjE,MAAI,CAAC,cAAc,GAAG;AAAG,UAAM,IAAI,MAAM,wDAAwD;AAEjG,SAAO,KAAK,UAAU,CAAC,GAAG,IAAI,QAAQ,IAAI,YAAY,IAAI,MAAM,IAAI,MAAM,IAAI,OAAO,CAAC;AACxF;AAEO,SAAS,aAAa,OAAsC;AACjE,MAAI,YAAY,OAAO,YAAY,OAAO,eAAe,KAAK,CAAC,CAAC;AAChE,SAAO,WAAW,SAAS;AAC7B;AAEA,IAAM,WAAW,CAAC,QAAiD,eAAe;AAE3E,SAAS,cAAiB,OAA8C;AAC7E,MAAI,CAAC,SAAS,KAAK;AAAG,WAAO;AAC7B,MAAI,OAAO,MAAM,SAAS;AAAU,WAAO;AAC3C,MAAI,OAAO,MAAM,YAAY;AAAU,WAAO;AAC9C,MAAI,OAAO,MAAM,eAAe;AAAU,WAAO;AACjD,MAAI,OAAO,MAAM,WAAW;AAAU,WAAO;AAC7C,MAAI,CAAC,MAAM,OAAO,MAAM,gBAAgB;AAAG,WAAO;AAElD,MAAI,CAAC,MAAM,QAAQ,MAAM,IAAI;AAAG,WAAO;AACvC,WAAS,IAAI,GAAG,IAAI,MAAM,KAAK,QAAQ,KAAK;AAC1C,QAAI,MAAM,MAAM,KAAK;AACrB,QAAI,CAAC,MAAM,QAAQ,GAAG;AAAG,aAAO;AAChC,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,UAAI,OAAO,IAAI,OAAO;AAAU,eAAO;AAAA,IACzC;AAAA,EACF;AAEA,SAAO;AACT;AAGO,SAAS,gBAAkC,OAA4C;AAC5F,MAAI,OAAO,MAAM,oBAAoB;AAAW,WAAO,MAAM;AAE7D,QAAM,OAAO,aAAa,KAAK;AAC/B,MAAI,SAAS,MAAM,IAAI;AACrB,WAAQ,MAAM,kBAAkB;AAAA,EAClC;AAEA,MAAI;AACF,WAAQ,MAAM,kBAAkB,QAAQ,OAAO,MAAM,KAAK,MAAM,MAAM,MAAM;AAAA,EAC9E,SAAS,KAAP;AACA,WAAQ,MAAM,kBAAkB;AAAA,EAClC;AACF;;;AErHO,SAAS,YAAY,QAAwB,OAA+B;AACjF,MAAI,OAAO,OAAO,OAAO,IAAI,QAAQ,MAAM,EAAE,MAAM,IAAI;AACrD,QAAI,CAAC,OAAO,IAAI,KAAK,YAAU,MAAM,GAAG,WAAW,MAAM,CAAC,GAAG;AAC3D,aAAO;AAAA,IACT;AAAA,EACF;AACA,MAAI,OAAO,SAAS,OAAO,MAAM,QAAQ,MAAM,IAAI,MAAM;AAAI,WAAO;AACpE,MAAI,OAAO,WAAW,OAAO,QAAQ,QAAQ,MAAM,MAAM,MAAM,IAAI;AACjE,QAAI,CAAC,OAAO,QAAQ,KAAK,YAAU,MAAM,OAAO,WAAW,MAAM,CAAC,GAAG;AACnE,aAAO;AAAA,IACT;AAAA,EACF;AAEA,WAAS,KAAK,QAAQ;AACpB,QAAI,EAAE,OAAO,KAAK;AAChB,UAAI,UAAU,EAAE,MAAM,CAAC;AACvB,UAAI,SAAS,OAAO,IAAI;AACxB,UAAI,UAAU,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,GAAG,CAAC,MAAM,MAAM,EAAE,MAAM,CAAC,KAAK,OAAQ,QAAQ,CAAC,MAAM,EAAE;AAAG,eAAO;AAAA,IACpG;AAAA,EACF;AAEA,MAAI,OAAO,SAAS,MAAM,aAAa,OAAO;AAAO,WAAO;AAC5D,MAAI,OAAO,SAAS,MAAM,aAAa,OAAO;AAAO,WAAO;AAE5D,SAAO;AACT;AAEO,SAAS,aAAa,SAA2B,OAA+B;AACrF,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,QAAI,YAAY,QAAQ,IAAI,KAAK;AAAG,aAAO;AAAA,EAC7C;AACA,SAAO;AACT;;;AC7CO,SAAS,SAAS,MAAc,OAAuB;AAC5D,MAAI,MAAM,MAAM,SAAS;AACzB,MAAI,MAAM,KAAK,QAAQ,IAAI,SAAS,IAAI;AACxC,MAAI,IAAI,KAAK,MAAM,GAAG,EAAE,QAAQ,GAAG,IAAI,MAAM;AAC7C,SAAO,KAAK,MAAM,GAAG,IAAI,EAAE;AAC7B;AAUO,SAAS,kBAAkB,MAA6B;AAC7D,MAAI,MAAM,KAAK,MAAM,GAAG,EAAE,EAAE,QAAQ,SAAS;AAC7C,MAAI,QAAQ;AAAI,WAAO;AAEvB,MAAI,SAAS,KAAK,MAAM,MAAM,IAAI,CAAC,EAAE,QAAQ,GAAG;AAChD,MAAI,WAAW;AAAI,WAAO;AAC1B,MAAI,QAAQ,MAAM,IAAI,IAAI;AAE1B,MAAI,OAAO,KAAK,MAAM,QAAQ,GAAG,EAAE,EAAE,QAAQ,GAAG;AAChD,MAAI,SAAS;AAAI,WAAO;AACxB,MAAI,MAAM,QAAQ,IAAI;AAEtB,SAAO,KAAK,MAAM,QAAQ,GAAG,GAAG;AAClC;;;ACwBA,IAAM,eAAe,OAAuD;AAAA,EAC1E,SAAS,CAAC;AAAA,EACV,YAAY,CAAC;AAAA,EACb,OAAO,CAAC;AAAA,EACR,QAAQ,CAAC;AAAA,EACT,MAAM,CAAC;AACT;AAEO,SAAS,UACd,KACA,UAII,CAAC,GACE;AACP,MAAI,EAAE,cAAc,KAAM,aAAa,KAAM,eAAe,IAAK,IAAI;AAErE,MAAI;AACJ,MAAI,WAA0E,CAAC;AAC/E,MAAI,YAAY,aAAa;AAC7B,MAAI,eAEA,CAAC;AACL,MAAI,eAKA,CAAC;AAEL,MAAI;AACJ,iBAAe,eAA8B;AAC3C,QAAI;AAAmB,aAAO;AAC9B,wBAAoB,IAAI,QAAQ,CAAC,SAAS,WAAW;AACnD,UAAI;AACF,aAAK,IAAI,UAAU,GAAG;AAAA,MACxB,SAAS,KAAP;AACA,eAAO,GAAG;AAAA,MACZ;AAEA,SAAG,SAAS,MAAM;AAChB,kBAAU,QAAQ,QAAQ,QAAM,GAAG,CAAC;AACpC,gBAAQ;AAAA,MACV;AACA,SAAG,UAAU,MAAM;AACjB,4BAAoB;AACpB,kBAAU,MAAM,QAAQ,QAAM,GAAG,CAAC;AAClC,eAAO;AAAA,MACT;AACA,SAAG,UAAU,YAAY;AACvB,4BAAoB;AACpB,kBAAU,WAAW,QAAQ,QAAM,GAAG,CAAC;AAAA,MACzC;AAEA,UAAI,uBAAqC,IAAI,aAAa;AAC1D,UAAI;AAEJ,SAAG,YAAY,OAAK;AAClB,6BAAqB,QAAQ,EAAE,IAAI;AACnC,YAAI,CAAC,oBAAoB;AACvB,+BAAqB,YAAY,YAAY,CAAC;AAAA,QAChD;AAAA,MACF;AAEA,eAAS,aAAa;AACpB,YAAI,qBAAqB,SAAS,GAAG;AACnC,wBAAc,kBAAkB;AAChC,+BAAqB;AACrB;AAAA,QACF;AAEA,YAAI,OAAO,qBAAqB,QAAQ;AACxC,YAAI,CAAC;AAAM;AAEX,YAAI,QAAQ,kBAAkB,IAAI;AAClC,YAAI,OAAO;AACT,cAAI,KAAK,SAAS;AAClB,cAAI,MAAM,GAAG,oBAAoB,GAAG,iBAAiB,SAAS,MAAM,IAAI,GAAG,GAAG,GAAG;AAC/E;AAAA,UACF;AAAA,QACF;AAEA,YAAI;AACF,cAAI,OAAO,KAAK,MAAM,IAAI;AAK1B,kBAAQ,KAAK,IAAI;AAAA,YACf,KAAK,SAAS;AACZ,kBAAIA,MAAK,KAAK;AACd,kBAAI,QAAQ,KAAK;AACjB,kBACE,cAAc,KAAK,KACnB,SAASA,SACR,SAASA,KAAI,oBAAoB,gBAAgB,KAAK,MACvD,aAAa,SAASA,KAAI,SAAS,KAAK,GACxC;AACA,yBAASA;AACR,iBAAC,aAAaA,MAAK,SAAS,CAAC,GAAG,QAAQ,QAAM,GAAG,KAAK,CAAC;AAAA,cAC1D;AACA;AAAA,YACF;AAAA,YACA,KAAK;AACH,kBAAI,KAAK,KAAK;AACd,kBAAI,UAAU,KAAK;AACnB,kBAAI,SAAS,KAAK;AAChB;AAAC,iBAAC,aAAa,KAAK,SAAS,CAAC,GAAG,QAAQ,QAAM,GAAG,OAAO,CAAC;AAAA,cAC5D;AACA;AAAA,YACF,KAAK,QAAQ;AACX,kBAAIA,MAAK,KAAK;AACd,kBAAIA,OAAM,cAAc;AACtB,6BAAaA,KAAI,KAAK,QAAQ,QAAM,GAAG,CAAC;AACxC,6BAAaA,KAAI,OAAO,CAAC;AAAA,cAC3B;AACA;AAAA,YACF;AAAA,YACA,KAAK,MAAM;AACT,kBAAIA,MAAa,KAAK;AACtB,kBAAI,KAAc,KAAK;AACvB,kBAAI,SAAiB,KAAK,MAAM;AAChC,kBAAIA,OAAM,cAAc;AACtB,oBAAI,EAAE,SAAAC,UAAS,QAAAC,QAAO,IAAI,aAAaF;AACvC,oBAAI;AAAI,kBAAAC,SAAQ,IAAI;AAAA;AACf,kBAAAC,QAAO,IAAI,MAAM,MAAM,CAAC;AAAA,cAC/B;AACA;AAAA,YACF;AAAA,YACA,KAAK;AACH,kBAAI,SAAS,KAAK;AAClB,wBAAU,OAAO,QAAQ,QAAM,GAAG,MAAM,CAAC;AACzC;AAAA,YACF,KAAK,QAAQ;AACX,kBAAI,YAAY,KAAK;AACrB,wBAAU,MAAM,QAAQ,QAAM,GAAG,SAAS,CAAC;AAC3C;AAAA,YACF;AAAA,UACF;AAAA,QACF,SAAS,KAAP;AACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAEA,WAAS,YAAY;AACnB,WAAO,IAAI,eAAe;AAAA,EAC5B;AAEA,iBAAe,UAAyB;AACtC,QAAI,UAAU;AAAG;AACjB,UAAM,aAAa;AAAA,EACrB;AAEA,iBAAe,QAAQ,QAA0B;AAC/C,QAAI,MAAM,KAAK,UAAU,MAAM;AAC/B,QAAI,CAAC,UAAU,GAAG;AAChB,YAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,GAAI,CAAC;AACtD,UAAI,CAAC,UAAU,GAAG;AAChB;AAAA,MACF;AAAA,IACF;AACA,QAAI;AACF,SAAG,KAAK,GAAG;AAAA,IACb,SAAS,KAAP;AACA,cAAQ,IAAI,GAAG;AAAA,IACjB;AAAA,EACF;AAEA,QAAM,MAAM,CACV,SACA;AAAA,IACE,OAAO;AAAA,IACP,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,IACnB,KAAK,KAAK,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC;AAAA,EACvC,IAAyB,CAAC,MACf;AACX,QAAI,QAAQ;AAEZ,aAAS,SAAS;AAAA,MAChB,IAAI;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,YAAQ,CAAC,MAAM,OAAO,GAAG,OAAO,CAAC;AAEjC,QAAI,eAAuB;AAAA,MACzB,KAAK,CAAC,YAAY,UAAU,CAAC,MAC3B,IAAI,cAAc,SAAS;AAAA,QACzB,kBAAkB,QAAQ,oBAAoB;AAAA,QAC9C,kBAAkB,QAAQ,oBAAoB;AAAA,QAC9C,IAAI;AAAA,MACN,CAAC;AAAA,MACH,OAAO,MAAM;AACX,eAAO,SAAS;AAChB,eAAO,aAAa;AACpB,gBAAQ,CAAC,SAAS,KAAK,CAAC;AAAA,MAC1B;AAAA,MACA,IAAI,CAAC,MAAM,OAAO;AAChB,qBAAa,SAAS,aAAa,UAAU;AAAA,UAC3C,OAAO,CAAC;AAAA,UACR,OAAO,CAAC;AAAA,UACR,MAAM,CAAC;AAAA,QACT;AACA,qBAAa,OAAO,MAAM,KAAK,EAAE;AAAA,MACnC;AAAA,MACA,KAAK,CAAC,MAAM,OAAa;AACvB,YAAIC,aAAY,aAAa;AAC7B,YAAI,MAAMA,WAAU,MAAM,QAAQ,EAAE;AACpC,YAAI,OAAO;AAAG,UAAAA,WAAU,MAAM,OAAO,KAAK,CAAC;AAAA,MAC7C;AAAA,MACA,IAAI,SAAS;AACX,eAAO,gBAAgB,YAAY;AAAA,MACrC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,cAAc,OAAsB,MAAc;AACzD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,CAAC,MAAM,IAAI;AACb,eAAO,IAAI,MAAM,SAAS,iBAAiB,CAAC;AAC5C;AAAA,MACF;AAEA,UAAI,KAAK,MAAM;AACf,cAAQ,CAAC,MAAM,KAAK,CAAC;AACrB,mBAAa,MAAM,EAAE,SAAS,OAAO;AAAA,IACvC,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,IAAI,CAAsD,MAAS,OAAgB;AACjF,gBAAU,MAAM,KAAK,EAAE;AACvB,UAAI,SAAS,aAAa,IAAI,eAAe,GAAG;AAE9C;AAAC,QAAC,GAAkB;AAAA,MACtB;AAAA,IACF;AAAA,IACA,KAAK,CAAsD,MAAS,OAAgB;AAClF,UAAI,QAAQ,UAAU,MAAM,QAAQ,EAAE;AACtC,UAAI,UAAU;AAAI,kBAAU,MAAM,OAAO,OAAO,CAAC;AAAA,IACnD;AAAA,IACA,MAAM,CAAC,SAAS,SACd,IAAI,QAAQ,aAAW;AACrB,UAAI,IAAI,IAAI,SAAS,IAAI;AACzB,UAAI,SAAuB,CAAC;AAC5B,UAAI,UAAU,WAAW,MAAM;AAC7B,UAAE,MAAM;AACR,gBAAQ,MAAM;AAAA,MAChB,GAAG,WAAW;AACd,QAAE,GAAG,QAAQ,MAAM;AACjB,UAAE,MAAM;AACR,qBAAa,OAAO;AACpB,gBAAQ,MAAM;AAAA,MAChB,CAAC;AACD,QAAE,GAAG,SAAS,WAAS;AACrB,eAAO,KAAK,KAAK;AAAA,MACnB,CAAC;AAAA,IACH,CAAC;AAAA,IACH,KAAK,CAAC,QAAQ,SACZ,IAAI,QAAQ,aAAW;AACrB,UAAI,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI;AAC1B,UAAI,UAAU,WAAW,MAAM;AAC7B,UAAE,MAAM;AACR,gBAAQ,IAAI;AAAA,MACd,GAAG,UAAU;AACb,QAAE,GAAG,SAAS,WAAS;AACrB,UAAE,MAAM;AACR,qBAAa,OAAO;AACpB,gBAAQ,KAAK;AAAA,MACf,CAAC;AAAA,IACH,CAAC;AAAA,IACH,OAAO,CAAC,YACN,IAAI,QAAQ,aAAW;AACrB,UAAI,IAAI,IAAI,SAAS,EAAE,GAAG,KAAK,MAAM,QAAQ,CAAC;AAC9C,UAAI,UAAU,WAAW,MAAM;AAC7B,UAAE,MAAM;AACR,gBAAQ,IAAI;AAAA,MACd,GAAG,YAAY;AACf,QAAE,GAAG,SAAS,CAAC,UAAwB;AACrC,UAAE,MAAM;AACR,qBAAa,OAAO;AACpB,gBAAQ,KAAK;AAAA,MACf,CAAC;AAAA,IACH,CAAC;AAAA,IACH,MAAM,QAAQ,OAAsB;AAClC,YAAM,cAAc,OAAO,OAAO;AAAA,IACpC;AAAA,IACA,MAAM,KAAK,OAAsB;AAC/B,YAAM,cAAc,OAAO,MAAM;AAAA,IACnC;AAAA,IACA;AAAA,IACA,QAAc;AACZ,kBAAY,aAAa;AACzB,qBAAe,CAAC;AAChB,qBAAe,CAAC;AAChB,UAAI,IAAI,eAAe,UAAU,MAAM;AACrC,WAAG,MAAM;AAAA,MACX;AAAA,IACF;AAAA,IACA,IAAI,SAAS;AACX,aAAO,IAAI,cAAc;AAAA,IAC3B;AAAA,EACF;AACF;AAEA,gBAAuB,gBAAkC,KAAsD;AAC7G,MAAI;AACJ,QAAM,aAAyB,CAAC;AAEhC,QAAM,cAAc,CAAC,UAAoB;AACvC,QAAI,aAAa;AACf,kBAAY,KAAK;AACjB,oBAAc;AAAA,IAChB,OAAO;AACL,iBAAW,KAAK,KAAK;AAAA,IACvB;AAAA,EACF;AAEA,MAAI,GAAG,SAAS,WAAW;AAE3B,MAAI;AACF,WAAO,MAAM;AACX,UAAI,WAAW,SAAS,GAAG;AACzB,cAAM,WAAW,MAAM;AAAA,MACzB,OAAO;AACL,cAAM,QAAQ,MAAM,IAAI,QAAkB,aAAW;AACnD,wBAAc;AAAA,QAChB,CAAC;AACD,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF,UAAE;AACA,QAAI,IAAI,SAAS,WAAW;AAAA,EAC9B;AACF;",
  "names": ["id", "resolve", "reject", "listeners"]
}

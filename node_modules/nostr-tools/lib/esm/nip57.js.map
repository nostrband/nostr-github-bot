{
  "version": 3,
  "sources": ["../../nip57.ts", "../../event.ts", "../../utils.ts"],
  "sourcesContent": ["import { bech32 } from '@scure/base'\n\nimport { Kind, validateEvent, verifySignature, type Event, type EventTemplate } from './event.ts'\nimport { utf8Decoder } from './utils.ts'\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function getZapEndpoint(metadata: Event<Kind.Metadata>): Promise<null | string> {\n  try {\n    let lnurl: string = ''\n    let { lud06, lud16 } = JSON.parse(metadata.content)\n    if (lud06) {\n      let { words } = bech32.decode(lud06, 1000)\n      let data = bech32.fromWords(words)\n      lnurl = utf8Decoder.decode(data)\n    } else if (lud16) {\n      let [name, domain] = lud16.split('@')\n      lnurl = `https://${domain}/.well-known/lnurlp/${name}`\n    } else {\n      return null\n    }\n\n    let res = await _fetch(lnurl)\n    let body = await res.json()\n\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback\n    }\n  } catch (err) {\n    /*-*/\n  }\n\n  return null\n}\n\nexport function makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = '',\n}: {\n  profile: string\n  event: string | null\n  amount: number\n  comment: string\n  relays: string[]\n}): EventTemplate<Kind.ZapRequest> {\n  if (!amount) throw new Error('amount not given')\n  if (!profile) throw new Error('profile not given')\n\n  let zr: EventTemplate<Kind.ZapRequest> = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1000),\n    content: comment,\n    tags: [\n      ['p', profile],\n      ['amount', amount.toString()],\n      ['relays', ...relays],\n    ],\n  }\n\n  if (event) {\n    zr.tags.push(['e', event])\n  }\n\n  return zr\n}\n\nexport function validateZapRequest(zapRequestString: string): string | null {\n  let zapRequest: Event\n\n  try {\n    zapRequest = JSON.parse(zapRequestString)\n  } catch (err) {\n    return 'Invalid zap request JSON.'\n  }\n\n  if (!validateEvent(zapRequest)) return 'Zap request is not a valid Nostr event.'\n\n  if (!verifySignature(zapRequest)) return 'Invalid signature on zap request.'\n\n  let p = zapRequest.tags.find(([t, v]) => t === 'p' && v)\n  if (!p) return \"Zap request doesn't have a 'p' tag.\"\n  if (!p[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'p' tag is not valid hex.\"\n\n  let e = zapRequest.tags.find(([t, v]) => t === 'e' && v)\n  if (e && !e[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'e' tag is not valid hex.\"\n\n  let relays = zapRequest.tags.find(([t, v]) => t === 'relays' && v)\n  if (!relays) return \"Zap request doesn't have a 'relays' tag.\"\n\n  return null\n}\n\nexport function makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt,\n}: {\n  zapRequest: string\n  preimage?: string\n  bolt11: string\n  paidAt: Date\n}): EventTemplate<Kind.Zap> {\n  let zr: Event<Kind.ZapRequest> = JSON.parse(zapRequest)\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === 'e' || t === 'p' || t === 'a')\n\n  let zap: EventTemplate<Kind.Zap> = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1000),\n    content: '',\n    tags: [...tagsFromZapRequest, ['bolt11', bolt11], ['description', zapRequest]],\n  }\n\n  if (preimage) {\n    zap.tags.push(['preimage', preimage])\n  }\n\n  return zap\n}\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nimport { getPublicKey } from './keys.ts'\nimport { utf8Encoder } from './utils.ts'\n\n/** Designates a verified event signature. */\nexport const verifiedSymbol = Symbol('verified')\n\n/** @deprecated Use numbers instead. */\n/* eslint-disable no-unused-vars */\nexport enum Kind {\n  Metadata = 0,\n  Text = 1,\n  RecommendRelay = 2,\n  Contacts = 3,\n  EncryptedDirectMessage = 4,\n  EventDeletion = 5,\n  Repost = 6,\n  Reaction = 7,\n  BadgeAward = 8,\n  ChannelCreation = 40,\n  ChannelMetadata = 41,\n  ChannelMessage = 42,\n  ChannelHideMessage = 43,\n  ChannelMuteUser = 44,\n  Blank = 255,\n  Report = 1984,\n  ZapRequest = 9734,\n  Zap = 9735,\n  RelayList = 10002,\n  ClientAuth = 22242,\n  NwcRequest = 23194,\n  HttpAuth = 27235,\n  ProfileBadge = 30008,\n  BadgeDefinition = 30009,\n  Article = 30023,\n  FileMetadata = 1063,\n}\n\nexport interface Event<K extends number = number> {\n  kind: K\n  tags: string[][]\n  content: string\n  created_at: number\n  pubkey: string\n  id: string\n  sig: string\n  [verifiedSymbol]?: boolean\n}\n\nexport type EventTemplate<K extends number = number> = Pick<Event<K>, 'kind' | 'tags' | 'content' | 'created_at'>\nexport type UnsignedEvent<K extends number = number> = Pick<\n  Event<K>,\n  'kind' | 'tags' | 'content' | 'created_at' | 'pubkey'\n>\n\n/** An event whose signature has been verified. */\nexport interface VerifiedEvent<K extends number = number> extends Event<K> {\n  [verifiedSymbol]: true\n}\n\nexport function getBlankEvent(): EventTemplate<Kind.Blank>\nexport function getBlankEvent<K extends number>(kind: K): EventTemplate<K>\nexport function getBlankEvent<K>(kind: K | Kind.Blank = Kind.Blank) {\n  return {\n    kind,\n    content: '',\n    tags: [],\n    created_at: 0,\n  }\n}\n\nexport function finishEvent<K extends number = number>(t: EventTemplate<K>, privateKey: string): VerifiedEvent<K> {\n  const event = t as VerifiedEvent<K>\n  event.pubkey = getPublicKey(privateKey)\n  event.id = getEventHash(event)\n  event.sig = getSignature(event, privateKey)\n  event[verifiedSymbol] = true\n  return event\n}\n\nexport function serializeEvent(evt: UnsignedEvent<number>): string {\n  if (!validateEvent(evt)) throw new Error(\"can't serialize event with wrong or missing properties\")\n\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])\n}\n\nexport function getEventHash(event: UnsignedEvent<number>): string {\n  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)))\n  return bytesToHex(eventHash)\n}\n\nconst isRecord = (obj: unknown): obj is Record<string, unknown> => obj instanceof Object\n\nexport function validateEvent<T>(event: T): event is T & UnsignedEvent<number> {\n  if (!isRecord(event)) return false\n  if (typeof event.kind !== 'number') return false\n  if (typeof event.content !== 'string') return false\n  if (typeof event.created_at !== 'number') return false\n  if (typeof event.pubkey !== 'string') return false\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false\n\n  if (!Array.isArray(event.tags)) return false\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i]\n    if (!Array.isArray(tag)) return false\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === 'object') return false\n    }\n  }\n\n  return true\n}\n\n/** Verify the event's signature. This function mutates the event with a `verified` symbol, making it idempotent. */\nexport function verifySignature<K extends number>(event: Event<K>): event is VerifiedEvent<K> {\n  if (typeof event[verifiedSymbol] === 'boolean') return event[verifiedSymbol]\n\n  const hash = getEventHash(event)\n  if (hash !== event.id) {\n    return (event[verifiedSymbol] = false)\n  }\n\n  try {\n    return (event[verifiedSymbol] = schnorr.verify(event.sig, hash, event.pubkey))\n  } catch (err) {\n    return (event[verifiedSymbol] = false)\n  }\n}\n\n/** @deprecated Use `getSignature` instead. */\nexport function signEvent(event: UnsignedEvent<number>, key: string): string {\n  console.warn(\n    'nostr-tools: `signEvent` is deprecated and will be removed or changed in the future. Please use `getSignature` instead.',\n  )\n  return getSignature(event, key)\n}\n\n/** Calculate the signature for an event. */\nexport function getSignature(event: UnsignedEvent<number>, key: string): string {\n  return bytesToHex(schnorr.sign(getEventHash(event), key))\n}\n", "import type { Event } from './event.ts'\n\nexport const utf8Decoder = new TextDecoder('utf-8')\nexport const utf8Encoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\n//\n// fast insert-into-sorted-array functions adapted from https://github.com/terrymorse58/fast-sorted-array\n//\nexport function insertEventIntoDescendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport class MessageNode {\n  private _value: string\n  private _next: MessageNode | null\n\n  public get value(): string {\n    return this._value\n  }\n  public set value(message: string) {\n    this._value = message\n  }\n  public get next(): MessageNode | null {\n    return this._next\n  }\n  public set next(node: MessageNode | null) {\n    this._next = node\n  }\n\n  constructor(message: string) {\n    this._value = message\n    this._next = null\n  }\n}\n\nexport class MessageQueue {\n  private _first: MessageNode | null\n  private _last: MessageNode | null\n\n  public get first(): MessageNode | null {\n    return this._first\n  }\n  public set first(messageNode: MessageNode | null) {\n    this._first = messageNode\n  }\n  public get last(): MessageNode | null {\n    return this._last\n  }\n  public set last(messageNode: MessageNode | null) {\n    this._last = messageNode\n  }\n  private _size: number\n  public get size(): number {\n    return this._size\n  }\n  public set size(v: number) {\n    this._size = v\n  }\n\n  constructor() {\n    this._first = null\n    this._last = null\n    this._size = 0\n  }\n  enqueue(message: string): boolean {\n    const newNode = new MessageNode(message)\n    if (this._size === 0 || !this._last) {\n      this._first = newNode\n      this._last = newNode\n    } else {\n      this._last.next = newNode\n      this._last = newNode\n    }\n    this._size++\n    return true\n  }\n  dequeue(): string | null {\n    if (this._size === 0 || !this._first) return null\n\n    let prev = this._first\n    this._first = prev.next\n    prev.next = null\n\n    this._size--\n    return prev.value\n  }\n}\n"],
  "mappings": "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",
  "names": []
}

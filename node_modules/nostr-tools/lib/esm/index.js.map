{
  "version": 3,
  "sources": ["../../keys.ts", "../../event.ts", "../../utils.ts", "../../filter.ts", "../../fakejson.ts", "../../relay.ts", "../../pool.ts", "../../nip19.ts", "../../references.ts", "../../nip04.ts", "../../nip05.ts", "../../nip06.ts", "../../nip10.ts", "../../nip13.ts", "../../nip18.ts", "../../nip21.ts", "../../nip25.ts", "../../nip26.ts", "../../nip27.ts", "../../nip28.ts", "../../nip39.ts", "../../nip42.ts", "../../nip44.ts", "../../nip47.ts", "../../nip57.ts", "../../nip98.ts"],
  "sourcesContent": ["import { schnorr } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nexport function generatePrivateKey(): string {\n  return bytesToHex(schnorr.utils.randomPrivateKey())\n}\n\nexport function getPublicKey(privateKey: string): string {\n  return bytesToHex(schnorr.getPublicKey(privateKey))\n}\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nimport { getPublicKey } from './keys.ts'\nimport { utf8Encoder } from './utils.ts'\n\n/** Designates a verified event signature. */\nexport const verifiedSymbol = Symbol('verified')\n\n/** @deprecated Use numbers instead. */\n/* eslint-disable no-unused-vars */\nexport enum Kind {\n  Metadata = 0,\n  Text = 1,\n  RecommendRelay = 2,\n  Contacts = 3,\n  EncryptedDirectMessage = 4,\n  EventDeletion = 5,\n  Repost = 6,\n  Reaction = 7,\n  BadgeAward = 8,\n  ChannelCreation = 40,\n  ChannelMetadata = 41,\n  ChannelMessage = 42,\n  ChannelHideMessage = 43,\n  ChannelMuteUser = 44,\n  Blank = 255,\n  Report = 1984,\n  ZapRequest = 9734,\n  Zap = 9735,\n  RelayList = 10002,\n  ClientAuth = 22242,\n  NwcRequest = 23194,\n  HttpAuth = 27235,\n  ProfileBadge = 30008,\n  BadgeDefinition = 30009,\n  Article = 30023,\n  FileMetadata = 1063,\n}\n\nexport interface Event<K extends number = number> {\n  kind: K\n  tags: string[][]\n  content: string\n  created_at: number\n  pubkey: string\n  id: string\n  sig: string\n  [verifiedSymbol]?: boolean\n}\n\nexport type EventTemplate<K extends number = number> = Pick<Event<K>, 'kind' | 'tags' | 'content' | 'created_at'>\nexport type UnsignedEvent<K extends number = number> = Pick<\n  Event<K>,\n  'kind' | 'tags' | 'content' | 'created_at' | 'pubkey'\n>\n\n/** An event whose signature has been verified. */\nexport interface VerifiedEvent<K extends number = number> extends Event<K> {\n  [verifiedSymbol]: true\n}\n\nexport function getBlankEvent(): EventTemplate<Kind.Blank>\nexport function getBlankEvent<K extends number>(kind: K): EventTemplate<K>\nexport function getBlankEvent<K>(kind: K | Kind.Blank = Kind.Blank) {\n  return {\n    kind,\n    content: '',\n    tags: [],\n    created_at: 0,\n  }\n}\n\nexport function finishEvent<K extends number = number>(t: EventTemplate<K>, privateKey: string): VerifiedEvent<K> {\n  const event = t as VerifiedEvent<K>\n  event.pubkey = getPublicKey(privateKey)\n  event.id = getEventHash(event)\n  event.sig = getSignature(event, privateKey)\n  event[verifiedSymbol] = true\n  return event\n}\n\nexport function serializeEvent(evt: UnsignedEvent<number>): string {\n  if (!validateEvent(evt)) throw new Error(\"can't serialize event with wrong or missing properties\")\n\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])\n}\n\nexport function getEventHash(event: UnsignedEvent<number>): string {\n  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)))\n  return bytesToHex(eventHash)\n}\n\nconst isRecord = (obj: unknown): obj is Record<string, unknown> => obj instanceof Object\n\nexport function validateEvent<T>(event: T): event is T & UnsignedEvent<number> {\n  if (!isRecord(event)) return false\n  if (typeof event.kind !== 'number') return false\n  if (typeof event.content !== 'string') return false\n  if (typeof event.created_at !== 'number') return false\n  if (typeof event.pubkey !== 'string') return false\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false\n\n  if (!Array.isArray(event.tags)) return false\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i]\n    if (!Array.isArray(tag)) return false\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === 'object') return false\n    }\n  }\n\n  return true\n}\n\n/** Verify the event's signature. This function mutates the event with a `verified` symbol, making it idempotent. */\nexport function verifySignature<K extends number>(event: Event<K>): event is VerifiedEvent<K> {\n  if (typeof event[verifiedSymbol] === 'boolean') return event[verifiedSymbol]\n\n  const hash = getEventHash(event)\n  if (hash !== event.id) {\n    return (event[verifiedSymbol] = false)\n  }\n\n  try {\n    return (event[verifiedSymbol] = schnorr.verify(event.sig, hash, event.pubkey))\n  } catch (err) {\n    return (event[verifiedSymbol] = false)\n  }\n}\n\n/** @deprecated Use `getSignature` instead. */\nexport function signEvent(event: UnsignedEvent<number>, key: string): string {\n  console.warn(\n    'nostr-tools: `signEvent` is deprecated and will be removed or changed in the future. Please use `getSignature` instead.',\n  )\n  return getSignature(event, key)\n}\n\n/** Calculate the signature for an event. */\nexport function getSignature(event: UnsignedEvent<number>, key: string): string {\n  return bytesToHex(schnorr.sign(getEventHash(event), key))\n}\n", "import type { Event } from './event.ts'\n\nexport const utf8Decoder = new TextDecoder('utf-8')\nexport const utf8Encoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\n//\n// fast insert-into-sorted-array functions adapted from https://github.com/terrymorse58/fast-sorted-array\n//\nexport function insertEventIntoDescendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport class MessageNode {\n  private _value: string\n  private _next: MessageNode | null\n\n  public get value(): string {\n    return this._value\n  }\n  public set value(message: string) {\n    this._value = message\n  }\n  public get next(): MessageNode | null {\n    return this._next\n  }\n  public set next(node: MessageNode | null) {\n    this._next = node\n  }\n\n  constructor(message: string) {\n    this._value = message\n    this._next = null\n  }\n}\n\nexport class MessageQueue {\n  private _first: MessageNode | null\n  private _last: MessageNode | null\n\n  public get first(): MessageNode | null {\n    return this._first\n  }\n  public set first(messageNode: MessageNode | null) {\n    this._first = messageNode\n  }\n  public get last(): MessageNode | null {\n    return this._last\n  }\n  public set last(messageNode: MessageNode | null) {\n    this._last = messageNode\n  }\n  private _size: number\n  public get size(): number {\n    return this._size\n  }\n  public set size(v: number) {\n    this._size = v\n  }\n\n  constructor() {\n    this._first = null\n    this._last = null\n    this._size = 0\n  }\n  enqueue(message: string): boolean {\n    const newNode = new MessageNode(message)\n    if (this._size === 0 || !this._last) {\n      this._first = newNode\n      this._last = newNode\n    } else {\n      this._last.next = newNode\n      this._last = newNode\n    }\n    this._size++\n    return true\n  }\n  dequeue(): string | null {\n    if (this._size === 0 || !this._first) return null\n\n    let prev = this._first\n    this._first = prev.next\n    prev.next = null\n\n    this._size--\n    return prev.value\n  }\n}\n", "import { Event } from './event.ts'\n\nexport type Filter<K extends number = number> = {\n  ids?: string[]\n  kinds?: K[]\n  authors?: string[]\n  since?: number\n  until?: number\n  limit?: number\n  search?: string\n  [key: `#${string}`]: string[] | undefined\n}\n\nexport function matchFilter(filter: Filter<number>, event: Event<number>): boolean {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    if (!filter.ids.some(prefix => event.id.startsWith(prefix))) {\n      return false\n    }\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    if (!filter.authors.some(prefix => event.pubkey.startsWith(prefix))) {\n      return false\n    }\n  }\n\n  for (let f in filter) {\n    if (f[0] === '#') {\n      let tagName = f.slice(1)\n      let values = filter[`#${tagName}`]\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values!.indexOf(v) !== -1)) return false\n    }\n  }\n\n  if (filter.since && event.created_at < filter.since) return false\n  if (filter.until && event.created_at > filter.until) return false\n\n  return true\n}\n\nexport function matchFilters(filters: Filter<number>[], event: Event<number>): boolean {\n  for (let i = 0; i < filters.length; i++) {\n    if (matchFilter(filters[i], event)) return true\n  }\n  return false\n}\n\nexport function mergeFilters(...filters: Filter<number>[]): Filter<number> {\n  let result: Filter<number> = {}\n  for (let i = 0; i < filters.length; i++) {\n    let filter = filters[i]\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === 'kinds' || property === 'ids' || property === 'authors' || property[0] === '#') {\n        // @ts-ignore\n        result[property] = result[property] || []\n        // @ts-ignore\n        for (let v = 0; v < values.length; v++) {\n          // @ts-ignore\n          let value = values[v]\n          // @ts-ignore\n          if (!result[property].includes(value)) result[property].push(value)\n        }\n      }\n    })\n\n    if (filter.limit && (!result.limit || filter.limit > result.limit)) result.limit = filter.limit\n    if (filter.until && (!result.until || filter.until > result.until)) result.until = filter.until\n    if (filter.since && (!result.since || filter.since < result.since)) result.since = filter.since\n  }\n\n  return result\n}\n", "export function getHex64(json: string, field: string): string {\n  let len = field.length + 3\n  let idx = json.indexOf(`\"${field}\":`) + len\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1\n  return json.slice(s, s + 64)\n}\n\nexport function getInt(json: string, field: string): number {\n  let len = field.length\n  let idx = json.indexOf(`\"${field}\":`) + len + 3\n  let sliced = json.slice(idx)\n  let end = Math.min(sliced.indexOf(','), sliced.indexOf('}'))\n  return parseInt(sliced.slice(0, end), 10)\n}\n\nexport function getSubscriptionId(json: string): string | null {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`)\n  if (idx === -1) return null\n\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`)\n  if (pstart === -1) return null\n  let start = idx + 7 + 1 + pstart\n\n  let pend = json.slice(start + 1, 80).indexOf(`\"`)\n  if (pend === -1) return null\n  let end = start + 1 + pend\n\n  return json.slice(start + 1, end)\n}\n\nexport function matchEventId(json: string, id: string): boolean {\n  return id === getHex64(json, 'id')\n}\n\nexport function matchEventPubkey(json: string, pubkey: string): boolean {\n  return pubkey === getHex64(json, 'pubkey')\n}\n\nexport function matchEventKind(json: string, kind: number): boolean {\n  return kind === getInt(json, 'kind')\n}\n", "/* global WebSocket */\n\nimport { verifySignature, validateEvent, type Event } from './event.ts'\nimport { matchFilters, type Filter } from './filter.ts'\nimport { getHex64, getSubscriptionId } from './fakejson.ts'\nimport { MessageQueue } from './utils.ts'\n\ntype RelayEvent = {\n  connect: () => void | Promise<void>\n  disconnect: () => void | Promise<void>\n  error: () => void | Promise<void>\n  notice: (msg: string) => void | Promise<void>\n  auth: (challenge: string) => void | Promise<void>\n}\nexport type CountPayload = {\n  count: number\n}\nexport type SubEvent<K extends number> = {\n  event: (event: Event<K>) => void | Promise<void>\n  count: (payload: CountPayload) => void | Promise<void>\n  eose: () => void | Promise<void>\n}\nexport type Relay = {\n  url: string\n  status: number\n  connect: () => Promise<void>\n  close: () => void\n  sub: <K extends number = number>(filters: Filter<K>[], opts?: SubscriptionOptions) => Sub<K>\n  list: <K extends number = number>(filters: Filter<K>[], opts?: SubscriptionOptions) => Promise<Event<K>[]>\n  get: <K extends number = number>(filter: Filter<K>, opts?: SubscriptionOptions) => Promise<Event<K> | null>\n  count: (filters: Filter[], opts?: SubscriptionOptions) => Promise<CountPayload | null>\n  publish: (event: Event<number>) => Promise<void>\n  auth: (event: Event<number>) => Promise<void>\n  off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(event: T, listener: U) => void\n  on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(event: T, listener: U) => void\n}\nexport type Sub<K extends number = number> = {\n  sub: <K extends number = number>(filters: Filter<K>[], opts: SubscriptionOptions) => Sub<K>\n  unsub: () => void\n  on: <T extends keyof SubEvent<K>, U extends SubEvent<K>[T]>(event: T, listener: U) => void\n  off: <T extends keyof SubEvent<K>, U extends SubEvent<K>[T]>(event: T, listener: U) => void\n  events: AsyncGenerator<Event<K>, void, unknown>\n}\n\nexport type SubscriptionOptions = {\n  id?: string\n  verb?: 'REQ' | 'COUNT'\n  skipVerification?: boolean\n  alreadyHaveEvent?: null | ((id: string, relay: string) => boolean)\n  eoseSubTimeout?: number\n}\n\nconst newListeners = (): { [TK in keyof RelayEvent]: RelayEvent[TK][] } => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: [],\n})\n\nexport function relayInit(\n  url: string,\n  options: {\n    getTimeout?: number\n    listTimeout?: number\n    countTimeout?: number\n  } = {},\n): Relay {\n  let { listTimeout = 3000, getTimeout = 3000, countTimeout = 3000 } = options\n\n  var ws: WebSocket\n  var openSubs: { [id: string]: { filters: Filter[] } & SubscriptionOptions } = {}\n  var listeners = newListeners()\n  var subListeners: {\n    [subid: string]: { [TK in keyof SubEvent<any>]: SubEvent<any>[TK][] }\n  } = {}\n  var pubListeners: {\n    [eventid: string]: {\n      resolve: (_: unknown) => void\n      reject: (err: Error) => void\n    }\n  } = {}\n\n  var connectionPromise: Promise<void> | undefined\n  async function connectRelay(): Promise<void> {\n    if (connectionPromise) return connectionPromise\n    connectionPromise = new Promise((resolve, reject) => {\n      try {\n        ws = new WebSocket(url)\n      } catch (err) {\n        reject(err)\n      }\n\n      ws.onopen = () => {\n        listeners.connect.forEach(cb => cb())\n        resolve()\n      }\n      ws.onerror = () => {\n        connectionPromise = undefined\n        listeners.error.forEach(cb => cb())\n        reject()\n      }\n      ws.onclose = async () => {\n        connectionPromise = undefined\n        listeners.disconnect.forEach(cb => cb())\n      }\n\n      let incomingMessageQueue: MessageQueue = new MessageQueue()\n      let handleNextInterval: any\n\n      ws.onmessage = e => {\n        incomingMessageQueue.enqueue(e.data)\n        if (!handleNextInterval) {\n          handleNextInterval = setInterval(handleNext, 0)\n        }\n      }\n\n      function handleNext() {\n        if (incomingMessageQueue.size === 0) {\n          clearInterval(handleNextInterval)\n          handleNextInterval = null\n          return\n        }\n\n        var json = incomingMessageQueue.dequeue()\n        if (!json) return\n\n        let subid = getSubscriptionId(json)\n        if (subid) {\n          let so = openSubs[subid]\n          if (so && so.alreadyHaveEvent && so.alreadyHaveEvent(getHex64(json, 'id'), url)) {\n            return\n          }\n        }\n\n        try {\n          let data = JSON.parse(json)\n\n          // we won't do any checks against the data since all failures (i.e. invalid messages from relays)\n          // will naturally be caught by the encompassing try..catch block\n\n          switch (data[0]) {\n            case 'EVENT': {\n              let id = data[1]\n              let event = data[2]\n              if (\n                validateEvent(event) &&\n                openSubs[id] &&\n                (openSubs[id].skipVerification || verifySignature(event)) &&\n                matchFilters(openSubs[id].filters, event)\n              ) {\n                openSubs[id]\n                ;(subListeners[id]?.event || []).forEach(cb => cb(event))\n              }\n              return\n            }\n            case 'COUNT':\n              let id = data[1]\n              let payload = data[2]\n              if (openSubs[id]) {\n                ;(subListeners[id]?.count || []).forEach(cb => cb(payload))\n              }\n              return\n            case 'EOSE': {\n              let id = data[1]\n              if (id in subListeners) {\n                subListeners[id].eose.forEach(cb => cb())\n                subListeners[id].eose = [] // 'eose' only happens once per sub, so stop listeners here\n              }\n              return\n            }\n            case 'OK': {\n              let id: string = data[1]\n              let ok: boolean = data[2]\n              let reason: string = data[3] || ''\n              if (id in pubListeners) {\n                let { resolve, reject } = pubListeners[id]\n                if (ok) resolve(null)\n                else reject(new Error(reason))\n              }\n              return\n            }\n            case 'NOTICE':\n              let notice = data[1]\n              listeners.notice.forEach(cb => cb(notice))\n              return\n            case 'AUTH': {\n              let challenge = data[1]\n              listeners.auth?.forEach(cb => cb(challenge))\n              return\n            }\n          }\n        } catch (err) {\n          return\n        }\n      }\n    })\n\n    return connectionPromise\n  }\n\n  function connected() {\n    return ws?.readyState === 1\n  }\n\n  async function connect(): Promise<void> {\n    if (connected()) return // ws already open\n    await connectRelay()\n  }\n\n  async function trySend(params: [string, ...any]) {\n    let msg = JSON.stringify(params)\n    if (!connected()) {\n      await new Promise(resolve => setTimeout(resolve, 1000))\n      if (!connected()) {\n        return\n      }\n    }\n    try {\n      ws.send(msg)\n    } catch (err) {\n      console.log(err)\n    }\n  }\n\n  const sub = <K extends number = number>(\n    filters: Filter<K>[],\n    {\n      verb = 'REQ',\n      skipVerification = false,\n      alreadyHaveEvent = null,\n      id = Math.random().toString().slice(2),\n    }: SubscriptionOptions = {},\n  ): Sub<K> => {\n    let subid = id\n\n    openSubs[subid] = {\n      id: subid,\n      filters,\n      skipVerification,\n      alreadyHaveEvent,\n    }\n    trySend([verb, subid, ...filters])\n\n    let subscription: Sub<K> = {\n      sub: (newFilters, newOpts = {}) =>\n        sub(newFilters || filters, {\n          skipVerification: newOpts.skipVerification || skipVerification,\n          alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,\n          id: subid,\n        }),\n      unsub: () => {\n        delete openSubs[subid]\n        delete subListeners[subid]\n        trySend(['CLOSE', subid])\n      },\n      on: (type, cb) => {\n        subListeners[subid] = subListeners[subid] || {\n          event: [],\n          count: [],\n          eose: [],\n        }\n        subListeners[subid][type].push(cb)\n      },\n      off: (type, cb): void => {\n        let listeners = subListeners[subid]\n        let idx = listeners[type].indexOf(cb)\n        if (idx >= 0) listeners[type].splice(idx, 1)\n      },\n      get events() {\n        return eventsGenerator(subscription)\n      },\n    }\n\n    return subscription\n  }\n\n  function _publishEvent(event: Event<number>, type: string) {\n    return new Promise((resolve, reject) => {\n      if (!event.id) {\n        reject(new Error(`event ${event} has no id`))\n        return\n      }\n\n      let id = event.id\n      trySend([type, event])\n      pubListeners[id] = { resolve, reject }\n    })\n  }\n\n  return {\n    url,\n    sub,\n    on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(type: T, cb: U): void => {\n      listeners[type].push(cb)\n      if (type === 'connect' && ws?.readyState === 1) {\n        // i would love to know why we need this\n        ;(cb as () => void)()\n      }\n    },\n    off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(type: T, cb: U): void => {\n      let index = listeners[type].indexOf(cb)\n      if (index !== -1) listeners[type].splice(index, 1)\n    },\n    list: (filters, opts?: SubscriptionOptions) =>\n      new Promise(resolve => {\n        let s = sub(filters, opts)\n        let events: Event<any>[] = []\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(events)\n        }, listTimeout)\n        s.on('eose', () => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(events)\n        })\n        s.on('event', event => {\n          events.push(event)\n        })\n      }),\n    get: (filter, opts?: SubscriptionOptions) =>\n      new Promise(resolve => {\n        let s = sub([filter], opts)\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, getTimeout)\n        s.on('event', event => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    count: (filters: Filter[]): Promise<CountPayload | null> =>\n      new Promise(resolve => {\n        let s = sub(filters, { ...sub, verb: 'COUNT' })\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, countTimeout)\n        s.on('count', (event: CountPayload) => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    async publish(event): Promise<void> {\n      await _publishEvent(event, 'EVENT')\n    },\n    async auth(event): Promise<void> {\n      await _publishEvent(event, 'AUTH')\n    },\n    connect,\n    close(): void {\n      listeners = newListeners()\n      subListeners = {}\n      pubListeners = {}\n      if (ws?.readyState === WebSocket.OPEN) {\n        ws.close()\n      }\n    },\n    get status() {\n      return ws?.readyState ?? 3\n    },\n  }\n}\n\nexport async function* eventsGenerator<K extends number>(sub: Sub<K>): AsyncGenerator<Event<K>, void, unknown> {\n  let nextResolve: ((event: Event<K>) => void) | undefined\n  const eventQueue: Event<K>[] = []\n\n  const pushToQueue = (event: Event<K>) => {\n    if (nextResolve) {\n      nextResolve(event)\n      nextResolve = undefined\n    } else {\n      eventQueue.push(event)\n    }\n  }\n\n  sub.on('event', pushToQueue)\n\n  try {\n    while (true) {\n      if (eventQueue.length > 0) {\n        yield eventQueue.shift()!\n      } else {\n        const event = await new Promise<Event<K>>(resolve => {\n          nextResolve = resolve\n        })\n        yield event\n      }\n    }\n  } finally {\n    sub.off('event', pushToQueue)\n  }\n}\n", "import { eventsGenerator, relayInit, type Relay, type Sub, type SubscriptionOptions } from './relay.ts'\nimport { normalizeURL } from './utils.ts'\n\nimport type { Event } from './event.ts'\nimport { matchFilters, mergeFilters, type Filter } from './filter.ts'\n\ntype BatchedRequest = {\n  filters: Filter<any>[]\n  relays: string[]\n  resolve: (events: Event<any>[]) => void\n  events: Event<any>[]\n}\n\nexport class SimplePool {\n  private _conn: { [url: string]: Relay }\n  private _seenOn: { [id: string]: Set<string> } = {} // a map of all events we've seen in each relay\n  private batchedByKey: { [batchKey: string]: BatchedRequest[] } = {}\n\n  private eoseSubTimeout: number\n  private getTimeout: number\n  private seenOnEnabled: boolean = true\n  private batchInterval: number = 100\n\n  constructor(\n    options: {\n      eoseSubTimeout?: number\n      getTimeout?: number\n      seenOnEnabled?: boolean\n      batchInterval?: number\n    } = {},\n  ) {\n    this._conn = {}\n    this.eoseSubTimeout = options.eoseSubTimeout || 3400\n    this.getTimeout = options.getTimeout || 3400\n    this.seenOnEnabled = options.seenOnEnabled !== false\n    this.batchInterval = options.batchInterval || 100\n  }\n\n  close(relays: string[]): void {\n    relays.forEach(url => {\n      let relay = this._conn[normalizeURL(url)]\n      if (relay) relay.close()\n    })\n  }\n\n  async ensureRelay(url: string): Promise<Relay> {\n    const nm = normalizeURL(url)\n\n    if (!this._conn[nm]) {\n      this._conn[nm] = relayInit(nm, {\n        getTimeout: this.getTimeout * 0.9,\n        listTimeout: this.getTimeout * 0.9,\n      })\n    }\n\n    const relay = this._conn[nm]\n    await relay.connect()\n    return relay\n  }\n\n  sub<K extends number = number>(relays: string[], filters: Filter<K>[], opts?: SubscriptionOptions): Sub<K> {\n    let _knownIds: Set<string> = new Set()\n    let modifiedOpts = { ...(opts || {}) }\n    modifiedOpts.alreadyHaveEvent = (id, url) => {\n      if (opts?.alreadyHaveEvent?.(id, url)) {\n        return true\n      }\n      if (this.seenOnEnabled) {\n        let set = this._seenOn[id] || new Set()\n        set.add(url)\n        this._seenOn[id] = set\n      }\n      return _knownIds.has(id)\n    }\n\n    let subs: Sub[] = []\n    let eventListeners: Set<any> = new Set()\n    let eoseListeners: Set<() => void> = new Set()\n    let eosesMissing = relays.length\n\n    let eoseSent = false\n    let eoseTimeout = setTimeout(\n      () => {\n        eoseSent = true\n        for (let cb of eoseListeners.values()) cb()\n      },\n      opts?.eoseSubTimeout || this.eoseSubTimeout,\n    )\n\n    relays\n      .filter((r, i, a) => a.indexOf(r) === i)\n      .forEach(async relay => {\n        let r\n        try {\n          r = await this.ensureRelay(relay)\n        } catch (err) {\n          handleEose()\n          return\n        }\n        if (!r) return\n        let s = r.sub(filters, modifiedOpts)\n        s.on('event', event => {\n          _knownIds.add(event.id as string)\n          for (let cb of eventListeners.values()) cb(event)\n        })\n        s.on('eose', () => {\n          if (eoseSent) return\n          handleEose()\n        })\n        subs.push(s)\n\n        function handleEose() {\n          eosesMissing--\n          if (eosesMissing === 0) {\n            clearTimeout(eoseTimeout)\n            for (let cb of eoseListeners.values()) cb()\n          }\n        }\n      })\n\n    let greaterSub: Sub<K> = {\n      sub(filters, opts) {\n        subs.forEach(sub => sub.sub(filters, opts))\n        return greaterSub as any\n      },\n      unsub() {\n        subs.forEach(sub => sub.unsub())\n      },\n      on(type, cb) {\n        if (type === 'event') {\n          eventListeners.add(cb)\n        } else if (type === 'eose') {\n          eoseListeners.add(cb as () => void | Promise<void>)\n        }\n      },\n      off(type, cb) {\n        if (type === 'event') {\n          eventListeners.delete(cb)\n        } else if (type === 'eose') eoseListeners.delete(cb as () => void | Promise<void>)\n      },\n      get events() {\n        return eventsGenerator(greaterSub)\n      },\n    }\n\n    return greaterSub\n  }\n\n  get<K extends number = number>(\n    relays: string[],\n    filter: Filter<K>,\n    opts?: SubscriptionOptions,\n  ): Promise<Event<K> | null> {\n    return new Promise(resolve => {\n      let sub = this.sub(relays, [filter], opts)\n      let timeout = setTimeout(() => {\n        sub.unsub()\n        resolve(null)\n      }, this.getTimeout)\n      sub.on('event', event => {\n        resolve(event)\n        clearTimeout(timeout)\n        sub.unsub()\n      })\n    })\n  }\n\n  list<K extends number = number>(\n    relays: string[],\n    filters: Filter<K>[],\n    opts?: SubscriptionOptions,\n  ): Promise<Event<K>[]> {\n    return new Promise(resolve => {\n      let events: Event<K>[] = []\n      let sub = this.sub(relays, filters, opts)\n\n      sub.on('event', event => {\n        events.push(event)\n      })\n\n      // we can rely on an eose being emitted here because pool.sub() will fake one\n      sub.on('eose', () => {\n        sub.unsub()\n        resolve(events)\n      })\n    })\n  }\n\n  batchedList<K extends number = number>(\n    batchKey: string,\n    relays: string[],\n    filters: Filter<K>[],\n  ): Promise<Event<K>[]> {\n    return new Promise(resolve => {\n      if (!this.batchedByKey[batchKey]) {\n        this.batchedByKey[batchKey] = [\n          {\n            filters,\n            relays,\n            resolve,\n            events: [],\n          },\n        ]\n\n        setTimeout(() => {\n          Object.keys(this.batchedByKey).forEach(async batchKey => {\n            const batchedRequests = this.batchedByKey[batchKey]\n\n            const filters = [] as Filter[]\n            const relays = [] as string[]\n            batchedRequests.forEach(br => {\n              filters.push(...br.filters)\n              relays.push(...br.relays)\n            })\n\n            const sub = this.sub(relays, [mergeFilters(...filters)])\n            sub.on('event', event => {\n              batchedRequests.forEach(br => matchFilters(br.filters, event) && br.events.push(event))\n            })\n            sub.on('eose', () => {\n              sub.unsub()\n              batchedRequests.forEach(br => br.resolve(br.events))\n            })\n\n            delete this.batchedByKey[batchKey]\n          })\n        }, this.batchInterval)\n      } else {\n        this.batchedByKey[batchKey].push({\n          filters,\n          relays,\n          resolve,\n          events: [],\n        })\n      }\n    })\n  }\n\n  publish(relays: string[], event: Event<number>): Promise<void>[] {\n    return relays.map(async relay => {\n      let r = await this.ensureRelay(relay)\n      return r.publish(event)\n    })\n  }\n\n  seenOn(id: string): string[] {\n    return Array.from(this._seenOn[id]?.values?.() || [])\n  }\n}\n", "import { bytesToHex, concatBytes, hexToBytes } from '@noble/hashes/utils'\nimport { bech32 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nconst Bech32MaxSize = 5000\n\n/**\n * Bech32 regex.\n * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32\n */\nexport const BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/\n\nfunction integerToUint8Array(number: number) {\n  // Create a Uint8Array with enough space to hold a 32-bit integer (4 bytes).\n  const uint8Array = new Uint8Array(4)\n\n  // Use bitwise operations to extract the bytes.\n  uint8Array[0] = (number >> 24) & 0xff // Most significant byte (MSB)\n  uint8Array[1] = (number >> 16) & 0xff\n  uint8Array[2] = (number >> 8) & 0xff\n  uint8Array[3] = number & 0xff // Least significant byte (LSB)\n\n  return uint8Array\n}\n\nexport type ProfilePointer = {\n  pubkey: string // hex\n  relays?: string[]\n}\n\nexport type EventPointer = {\n  id: string // hex\n  relays?: string[]\n  author?: string\n  kind?: number\n}\n\nexport type AddressPointer = {\n  identifier: string\n  pubkey: string\n  kind: number\n  relays?: string[]\n}\n\ntype Prefixes = {\n  nprofile: ProfilePointer\n  nrelay: string\n  nevent: EventPointer\n  naddr: AddressPointer\n  nsec: string\n  npub: string\n  note: string\n}\n\ntype DecodeValue<Prefix extends keyof Prefixes> = {\n  type: Prefix\n  data: Prefixes[Prefix]\n}\n\nexport type DecodeResult = {\n  [P in keyof Prefixes]: DecodeValue<P>\n}[keyof Prefixes]\n\nexport function decode<Prefix extends keyof Prefixes>(nip19: `${Prefix}1${string}`): DecodeValue<Prefix>\nexport function decode(nip19: string): DecodeResult\nexport function decode(nip19: string): DecodeResult {\n  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize)\n  let data = new Uint8Array(bech32.fromWords(words))\n\n  switch (prefix) {\n    case 'nprofile': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nprofile')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n\n      return {\n        type: 'nprofile',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n    case 'nevent': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nevent')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (tlv[2] && tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (tlv[3] && tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'nevent',\n        data: {\n          id: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : undefined,\n          kind: tlv[3]?.[0] ? parseInt(bytesToHex(tlv[3][0]), 16) : undefined,\n        },\n      }\n    }\n\n    case 'naddr': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for naddr')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for naddr')\n      if (tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for naddr')\n      if (tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'naddr',\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: bytesToHex(tlv[2][0]),\n          kind: parseInt(bytesToHex(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n\n    case 'nrelay': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nrelay')\n\n      return {\n        type: 'nrelay',\n        data: utf8Decoder.decode(tlv[0][0]),\n      }\n    }\n\n    case 'nsec':\n    case 'npub':\n    case 'note':\n      return { type: prefix, data: bytesToHex(data) }\n\n    default:\n      throw new Error(`unknown prefix ${prefix}`)\n  }\n}\n\ntype TLV = { [t: number]: Uint8Array[] }\n\nfunction parseTLV(data: Uint8Array): TLV {\n  let result: TLV = {}\n  let rest = data\n  while (rest.length > 0) {\n    let t = rest[0]\n    let l = rest[1]\n    if (!l) throw new Error(`malformed TLV ${t}`)\n    let v = rest.slice(2, 2 + l)\n    rest = rest.slice(2 + l)\n    if (v.length < l) throw new Error(`not enough data to read on TLV ${t}`)\n    result[t] = result[t] || []\n    result[t].push(v)\n  }\n  return result\n}\n\nexport function nsecEncode(hex: string): `nsec1${string}` {\n  return encodeBytes('nsec', hex)\n}\n\nexport function npubEncode(hex: string): `npub1${string}` {\n  return encodeBytes('npub', hex)\n}\n\nexport function noteEncode(hex: string): `note1${string}` {\n  return encodeBytes('note', hex)\n}\n\nfunction encodeBech32<Prefix extends string>(prefix: Prefix, data: Uint8Array): `${Prefix}1${string}` {\n  let words = bech32.toWords(data)\n  return bech32.encode(prefix, words, Bech32MaxSize) as `${Prefix}1${string}`\n}\n\nfunction encodeBytes<Prefix extends string>(prefix: Prefix, hex: string): `${Prefix}1${string}` {\n  let data = hexToBytes(hex)\n  return encodeBech32(prefix, data)\n}\n\nexport function nprofileEncode(profile: ProfilePointer): `nprofile1${string}` {\n  let data = encodeTLV({\n    0: [hexToBytes(profile.pubkey)],\n    1: (profile.relays || []).map(url => utf8Encoder.encode(url)),\n  })\n  return encodeBech32('nprofile', data)\n}\n\nexport function neventEncode(event: EventPointer): `nevent1${string}` {\n  let kindArray\n  if (event.kind != undefined) {\n    kindArray = integerToUint8Array(event.kind)\n  }\n\n  let data = encodeTLV({\n    0: [hexToBytes(event.id)],\n    1: (event.relays || []).map(url => utf8Encoder.encode(url)),\n    2: event.author ? [hexToBytes(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : [],\n  })\n\n  return encodeBech32('nevent', data)\n}\n\nexport function naddrEncode(addr: AddressPointer): `naddr1${string}` {\n  let kind = new ArrayBuffer(4)\n  new DataView(kind).setUint32(0, addr.kind, false)\n\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map(url => utf8Encoder.encode(url)),\n    2: [hexToBytes(addr.pubkey)],\n    3: [new Uint8Array(kind)],\n  })\n  return encodeBech32('naddr', data)\n}\n\nexport function nrelayEncode(url: string): `nrelay1${string}` {\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(url)],\n  })\n  return encodeBech32('nrelay', data)\n}\n\nfunction encodeTLV(tlv: TLV): Uint8Array {\n  let entries: Uint8Array[] = []\n\n  Object.entries(tlv).forEach(([t, vs]) => {\n    vs.forEach(v => {\n      let entry = new Uint8Array(v.length + 2)\n      entry.set([parseInt(t)], 0)\n      entry.set([v.length], 1)\n      entry.set(v, 2)\n      entries.push(entry)\n    })\n  })\n\n  return concatBytes(...entries)\n}\n", "import { decode, type AddressPointer, type ProfilePointer, type EventPointer } from './nip19.ts'\n\nimport type { Event } from './event.ts'\n\ntype Reference = {\n  text: string\n  profile?: ProfilePointer\n  event?: EventPointer\n  address?: AddressPointer\n}\n\nconst mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g\n\nexport function parseReferences(evt: Event): Reference[] {\n  let references: Reference[] = []\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      // it's a NIP-27 mention\n      try {\n        let { type, data } = decode(ref[1])\n        switch (type) {\n          case 'npub': {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data as string, relays: [] },\n            })\n            break\n          }\n          case 'nprofile': {\n            references.push({\n              text: ref[0],\n              profile: data as ProfilePointer,\n            })\n            break\n          }\n          case 'note': {\n            references.push({\n              text: ref[0],\n              event: { id: data as string, relays: [] },\n            })\n            break\n          }\n          case 'nevent': {\n            references.push({\n              text: ref[0],\n              event: data as EventPointer,\n            })\n            break\n          }\n          case 'naddr': {\n            references.push({\n              text: ref[0],\n              address: data as AddressPointer,\n            })\n            break\n          }\n        }\n      } catch (err) {\n        /***/\n      }\n    } else if (ref[3]) {\n      // it's a NIP-10 mention\n      let idx = parseInt(ref[3], 10)\n      let tag = evt.tags[idx]\n      if (!tag) continue\n\n      switch (tag[0]) {\n        case 'p': {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] },\n          })\n          break\n        }\n        case 'e': {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] },\n          })\n          break\n        }\n        case 'a': {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(':')\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : [],\n              },\n            })\n          } catch (err) {\n            /***/\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return references\n}\n", "import { randomBytes } from '@noble/hashes/utils'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { base64 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\n// @ts-ignore\nif (typeof crypto !== 'undefined' && !crypto.subtle && crypto.webcrypto) {\n  // @ts-ignore\n  crypto.subtle = crypto.webcrypto.subtle\n}\n\nexport async function encrypt(privkey: string, pubkey: string, text: string): Promise<string> {\n  const key = secp256k1.getSharedSecret(privkey, '02' + pubkey)\n  const normalizedKey = getNormalizedX(key)\n\n  let iv = Uint8Array.from(randomBytes(16))\n  let plaintext = utf8Encoder.encode(text)\n  let cryptoKey = await crypto.subtle.importKey('raw', normalizedKey, { name: 'AES-CBC' }, false, ['encrypt'])\n  let ciphertext = await crypto.subtle.encrypt({ name: 'AES-CBC', iv }, cryptoKey, plaintext)\n  let ctb64 = base64.encode(new Uint8Array(ciphertext))\n  let ivb64 = base64.encode(new Uint8Array(iv.buffer))\n\n  return `${ctb64}?iv=${ivb64}`\n}\n\nexport async function decrypt(privkey: string, pubkey: string, data: string): Promise<string> {\n  let [ctb64, ivb64] = data.split('?iv=')\n  let key = secp256k1.getSharedSecret(privkey, '02' + pubkey)\n  let normalizedKey = getNormalizedX(key)\n\n  let cryptoKey = await crypto.subtle.importKey('raw', normalizedKey, { name: 'AES-CBC' }, false, ['decrypt'])\n  let ciphertext = base64.decode(ctb64)\n  let iv = base64.decode(ivb64)\n\n  let plaintext = await crypto.subtle.decrypt({ name: 'AES-CBC', iv }, cryptoKey, ciphertext)\n\n  let text = utf8Decoder.decode(plaintext)\n  return text\n}\n\nfunction getNormalizedX(key: Uint8Array): Uint8Array {\n  return key.slice(1, 33)\n}\n", "import { ProfilePointer } from './nip19.ts'\n\n/**\n * NIP-05 regex. The localpart is optional, and should be assumed to be `_` otherwise.\n *\n * - 0: full match\n * - 1: name (optional)\n * - 2: domain\n */\nexport const NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function searchDomain(domain: string, query = ''): Promise<{ [name: string]: string }> {\n  try {\n    let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json()\n\n    return res.names\n  } catch (_) {\n    return {}\n  }\n}\n\nexport async function queryProfile(fullname: string): Promise<ProfilePointer | null> {\n  const match = fullname.match(NIP05_REGEX)\n  if (!match) return null\n\n  const [_, name = '_', domain] = match\n\n  try {\n    const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)\n    const { names, relays } = parseNIP05Result(await res.json())\n\n    const pubkey = names[name]\n    return pubkey ? { pubkey, relays: relays?.[pubkey] } : null\n  } catch (_e) {\n    return null\n  }\n}\n\n/** nostr.json result. */\nexport interface NIP05Result {\n  names: {\n    [name: string]: string\n  }\n  relays?: {\n    [pubkey: string]: string[]\n  }\n}\n\n/** Parse the nostr.json and throw if it's not valid. */\nfunction parseNIP05Result(json: any): NIP05Result {\n  const result: NIP05Result = {\n    names: {},\n  }\n\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === 'string' && typeof pubkey === 'string') {\n      result.names[name] = pubkey\n    }\n  }\n\n  if (json.relays) {\n    result.relays = {}\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === 'string' && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay: unknown) => typeof relay === 'string')\n      }\n    }\n  }\n\n  return result\n}\n", "import { bytesToHex } from '@noble/hashes/utils'\nimport { wordlist } from '@scure/bip39/wordlists/english'\nimport { generateMnemonic, mnemonicToSeedSync, validateMnemonic } from '@scure/bip39'\nimport { HDKey } from '@scure/bip32'\n\nexport function privateKeyFromSeedWords(mnemonic: string, passphrase?: string): string {\n  let root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase))\n  let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey\n  if (!privateKey) throw new Error('could not derive private key')\n  return bytesToHex(privateKey)\n}\n\nexport function generateSeedWords(): string {\n  return generateMnemonic(wordlist)\n}\n\nexport function validateWords(words: string): boolean {\n  return validateMnemonic(words, wordlist)\n}\n", "import type { Event } from './event.ts'\nimport type { EventPointer, ProfilePointer } from './nip19.ts'\n\nexport type NIP10Result = {\n  /**\n   * Pointer to the root of the thread.\n   */\n  root: EventPointer | undefined\n\n  /**\n   * Pointer to a \"parent\" event that parsed event replies to (responded to).\n   */\n  reply: EventPointer | undefined\n\n  /**\n   * Pointers to events which may or may not be in the reply chain.\n   */\n  mentions: EventPointer[]\n\n  /**\n   * List of pubkeys that are involved in the thread in no particular order.\n   */\n  profiles: ProfilePointer[]\n}\n\nexport function parse(event: Pick<Event, 'tags'>): NIP10Result {\n  const result: NIP10Result = {\n    reply: undefined,\n    root: undefined,\n    mentions: [],\n    profiles: [],\n  }\n\n  const eTags: string[][] = []\n\n  for (const tag of event.tags) {\n    if (tag[0] === 'e' && tag[1]) {\n      eTags.push(tag)\n    }\n\n    if (tag[0] === 'p' && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : [],\n      })\n    }\n  }\n\n  for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {\n    const eTag = eTags[eTagIndex]\n\n    const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag as [string, string, undefined | string, undefined | string]\n\n    const eventPointer: EventPointer = {\n      id: eTagEventId,\n      relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n    }\n\n    const isFirstETag = eTagIndex === 0\n    const isLastETag = eTagIndex === eTags.length - 1\n\n    if (eTagMarker === 'root') {\n      result.root = eventPointer\n      continue\n    }\n\n    if (eTagMarker === 'reply') {\n      result.reply = eventPointer\n      continue\n    }\n\n    if (eTagMarker === 'mention') {\n      result.mentions.push(eventPointer)\n      continue\n    }\n\n    if (isFirstETag) {\n      result.root = eventPointer\n      continue\n    }\n\n    if (isLastETag) {\n      result.reply = eventPointer\n      continue\n    }\n\n    result.mentions.push(eventPointer)\n  }\n\n  return result\n}\n", "import { type UnsignedEvent, type Event, getEventHash } from './event.ts'\n\n/** Get POW difficulty from a Nostr hex ID. */\nexport function getPow(hex: string): number {\n  let count = 0\n\n  for (let i = 0; i < hex.length; i++) {\n    const nibble = parseInt(hex[i], 16)\n    if (nibble === 0) {\n      count += 4\n    } else {\n      count += Math.clz32(nibble) - 28\n      break\n    }\n  }\n\n  return count\n}\n\n/**\n * Mine an event with the desired POW. This function mutates the event.\n * Note that this operation is synchronous and should be run in a worker context to avoid blocking the main thread.\n *\n * Adapted from Snort: https://git.v0l.io/Kieran/snort/src/commit/4df6c19248184218c4c03728d61e94dae5f2d90c/packages/system/src/pow-util.ts#L14-L36\n */\nexport function minePow<K extends number>(unsigned: UnsignedEvent<K>, difficulty: number): Omit<Event<K>, 'sig'> {\n  let count = 0\n\n  const event = unsigned as Omit<Event<K>, 'sig'>\n  const tag = ['nonce', count.toString(), difficulty.toString()]\n\n  event.tags.push(tag)\n\n  while (true) {\n    const now = Math.floor(new Date().getTime() / 1000)\n\n    if (now !== event.created_at) {\n      count = 0\n      event.created_at = now\n    }\n\n    tag[1] = (++count).toString()\n\n    event.id = getEventHash(event)\n\n    if (getPow(event.id) >= difficulty) {\n      break\n    }\n  }\n\n  return event\n}\n", "import { Event, finishEvent, Kind, verifySignature } from './event.ts'\nimport { EventPointer } from './nip19.ts'\n\nexport type RepostEventTemplate = {\n  /**\n   * Pass only non-nip18 tags if you have to.\n   * Nip18 tags ('e' and 'p' tags pointing to the reposted event) will be added automatically.\n   */\n  tags?: string[][]\n\n  /**\n   * Pass an empty string to NOT include the stringified JSON of the reposted event.\n   * Any other content will be ignored and replaced with the stringified JSON of the reposted event.\n   * @default Stringified JSON of the reposted event\n   */\n  content?: ''\n\n  created_at: number\n}\n\nexport function finishRepostEvent(\n  t: RepostEventTemplate,\n  reposted: Event<number>,\n  relayUrl: string,\n  privateKey: string,\n): Event<Kind.Repost> {\n  return finishEvent(\n    {\n      kind: Kind.Repost,\n      tags: [...(t.tags ?? []), ['e', reposted.id, relayUrl], ['p', reposted.pubkey]],\n      content: t.content === '' ? '' : JSON.stringify(reposted),\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport function getRepostedEventPointer(event: Event<number>): undefined | EventPointer {\n  if (event.kind !== Kind.Repost) {\n    return undefined\n  }\n\n  let lastETag: undefined | string[]\n  let lastPTag: undefined | string[]\n\n  for (let i = event.tags.length - 1; i >= 0 && (lastETag === undefined || lastPTag === undefined); i--) {\n    const tag = event.tags[i]\n    if (tag.length >= 2) {\n      if (tag[0] === 'e' && lastETag === undefined) {\n        lastETag = tag\n      } else if (tag[0] === 'p' && lastPTag === undefined) {\n        lastPTag = tag\n      }\n    }\n  }\n\n  if (lastETag === undefined) {\n    return undefined\n  }\n\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x): x is string => typeof x === 'string'),\n    author: lastPTag?.[1],\n  }\n}\n\nexport type GetRepostedEventOptions = {\n  skipVerification?: boolean\n}\n\nexport function getRepostedEvent(\n  event: Event<number>,\n  { skipVerification }: GetRepostedEventOptions = {},\n): undefined | Event<number> {\n  const pointer = getRepostedEventPointer(event)\n\n  if (pointer === undefined || event.content === '') {\n    return undefined\n  }\n\n  let repostedEvent: undefined | Event<number>\n\n  try {\n    repostedEvent = JSON.parse(event.content) as Event<number>\n  } catch (error) {\n    return undefined\n  }\n\n  if (repostedEvent.id !== pointer.id) {\n    return undefined\n  }\n\n  if (!skipVerification && !verifySignature(repostedEvent)) {\n    return undefined\n  }\n\n  return repostedEvent\n}\n", "import { BECH32_REGEX, decode, type DecodeResult } from './nip19.ts'\n\n/** Nostr URI regex, eg `nostr:npub1...` */\nexport const NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`)\n\n/** Test whether the value is a Nostr URI. */\nexport function test(value: unknown): value is `nostr:${string}` {\n  return typeof value === 'string' && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value)\n}\n\n/** Parsed Nostr URI data. */\nexport interface NostrURI {\n  /** Full URI including the `nostr:` protocol. */\n  uri: `nostr:${string}`\n  /** The bech32-encoded data (eg `npub1...`). */\n  value: string\n  /** Decoded bech32 string, according to NIP-19. */\n  decoded: DecodeResult\n}\n\n/** Parse and decode a Nostr URI. */\nexport function parse(uri: string): NostrURI {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`))\n  if (!match) throw new Error(`Invalid Nostr URI: ${uri}`)\n  return {\n    uri: match[0] as `nostr:${string}`,\n    value: match[1],\n    decoded: decode(match[1]),\n  }\n}\n", "import { Event, finishEvent, Kind } from './event.ts'\n\nimport type { EventPointer } from './nip19.ts'\n\nexport type ReactionEventTemplate = {\n  /**\n   * Pass only non-nip25 tags if you have to. Nip25 tags ('e' and 'p' tags from reacted event) will be added automatically.\n   */\n  tags?: string[][]\n\n  /**\n   * @default '+'\n   */\n  content?: string\n\n  created_at: number\n}\n\nexport function finishReactionEvent(\n  t: ReactionEventTemplate,\n  reacted: Event<number>,\n  privateKey: string,\n): Event<Kind.Reaction> {\n  const inheritedTags = reacted.tags.filter(tag => tag.length >= 2 && (tag[0] === 'e' || tag[0] === 'p'))\n\n  return finishEvent(\n    {\n      ...t,\n      kind: Kind.Reaction,\n      tags: [...(t.tags ?? []), ...inheritedTags, ['e', reacted.id], ['p', reacted.pubkey]],\n      content: t.content ?? '+',\n    },\n    privateKey,\n  )\n}\n\nexport function getReactedEventPointer(event: Event<number>): undefined | EventPointer {\n  if (event.kind !== Kind.Reaction) {\n    return undefined\n  }\n\n  let lastETag: undefined | string[]\n  let lastPTag: undefined | string[]\n\n  for (let i = event.tags.length - 1; i >= 0 && (lastETag === undefined || lastPTag === undefined); i--) {\n    const tag = event.tags[i]\n    if (tag.length >= 2) {\n      if (tag[0] === 'e' && lastETag === undefined) {\n        lastETag = tag\n      } else if (tag[0] === 'p' && lastPTag === undefined) {\n        lastPTag = tag\n      }\n    }\n  }\n\n  if (lastETag === undefined || lastPTag === undefined) {\n    return undefined\n  }\n\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter(x => x !== undefined),\n    author: lastPTag[1],\n  }\n}\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@noble/hashes/utils'\nimport { sha256 } from '@noble/hashes/sha256'\n\nimport { utf8Encoder } from './utils.ts'\nimport { getPublicKey } from './keys.ts'\n\nimport type { Event } from './event.ts'\n\nexport type Parameters = {\n  pubkey: string // the key to whom the delegation will be given\n  kind?: number\n  until?: number // delegation will only be valid until this date\n  since?: number // delegation will be valid from this date on\n}\n\nexport type Delegation = {\n  from: string // the pubkey who signed the delegation\n  to: string // the pubkey that is allowed to use the delegation\n  cond: string // the string of conditions as they should be included in the event tag\n  sig: string\n}\n\nexport function createDelegation(privateKey: string, parameters: Parameters): Delegation {\n  let conditions = []\n  if ((parameters.kind || -1) >= 0) conditions.push(`kind=${parameters.kind}`)\n  if (parameters.until) conditions.push(`created_at<${parameters.until}`)\n  if (parameters.since) conditions.push(`created_at>${parameters.since}`)\n  let cond = conditions.join('&')\n\n  if (cond === '') throw new Error('refusing to create a delegation without any conditions')\n\n  let sighash = sha256(utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`))\n\n  let sig = bytesToHex(schnorr.sign(sighash, privateKey))\n\n  return {\n    from: getPublicKey(privateKey),\n    to: parameters.pubkey,\n    cond,\n    sig,\n  }\n}\n\nexport function getDelegator(event: Event<number>): string | null {\n  // find delegation tag\n  let tag = event.tags.find(tag => tag[0] === 'delegation' && tag.length >= 4)\n  if (!tag) return null\n\n  let pubkey = tag[1]\n  let cond = tag[2]\n  let sig = tag[3]\n\n  // check conditions\n  let conditions = cond.split('&')\n  for (let i = 0; i < conditions.length; i++) {\n    let [key, operator, value] = conditions[i].split(/\\b/)\n\n    // the supported conditions are just 'kind' and 'created_at' for now\n    if (key === 'kind' && operator === '=' && event.kind === parseInt(value)) continue\n    else if (key === 'created_at' && operator === '<' && event.created_at < parseInt(value)) continue\n    else if (key === 'created_at' && operator === '>' && event.created_at > parseInt(value)) continue\n    else return null // invalid condition\n  }\n\n  // check signature\n  let sighash = sha256(utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`))\n  if (!schnorr.verify(sig, sighash, pubkey)) return null\n\n  return pubkey\n}\n", "import { decode } from './nip19.ts'\nimport { NOSTR_URI_REGEX, type NostrURI } from './nip21.ts'\n\n/** Regex to find NIP-21 URIs inside event content. */\nexport const regex = () => new RegExp(`\\\\b${NOSTR_URI_REGEX.source}\\\\b`, 'g')\n\n/** Match result for a Nostr URI in event content. */\nexport interface NostrURIMatch extends NostrURI {\n  /** Index where the URI begins in the event content. */\n  start: number\n  /** Index where the URI ends in the event content. */\n  end: number\n}\n\n/** Find and decode all NIP-21 URIs. */\nexport function* matchAll(content: string): Iterable<NostrURIMatch> {\n  const matches = content.matchAll(regex())\n\n  for (const match of matches) {\n    try {\n      const [uri, value] = match\n\n      yield {\n        uri: uri as `nostr:${string}`,\n        value,\n        decoded: decode(value),\n        start: match.index!,\n        end: match.index! + uri.length,\n      }\n    } catch (_e) {\n      // do nothing\n    }\n  }\n}\n\n/**\n * Replace all occurrences of Nostr URIs in the text.\n *\n * WARNING: using this on an HTML string is potentially unsafe!\n *\n * @example\n * ```ts\n * nip27.replaceAll(event.content, ({ decoded, value }) => {\n *   switch(decoded.type) {\n *     case 'npub':\n *       return renderMention(decoded)\n *     case 'note':\n *       return renderNote(decoded)\n *     default:\n *       return value\n *   }\n * })\n * ```\n */\nexport function replaceAll(content: string, replacer: (match: NostrURI) => string): string {\n  return content.replaceAll(regex(), (uri, value: string) => {\n    return replacer({\n      uri: uri as `nostr:${string}`,\n      value,\n      decoded: decode(value),\n    })\n  })\n}\n", "import { Event, finishEvent, Kind } from './event.ts'\n\nexport interface ChannelMetadata {\n  name: string\n  about: string\n  picture: string\n}\n\nexport interface ChannelCreateEventTemplate {\n  /* JSON string containing ChannelMetadata as defined for Kind 40 and 41 in nip-28. */\n  content: string | ChannelMetadata\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelMetadataEventTemplate {\n  channel_create_event_id: string\n  /* JSON string containing ChannelMetadata as defined for Kind 40 and 41 in nip-28. */\n  content: string | ChannelMetadata\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelMessageEventTemplate {\n  channel_create_event_id: string\n  reply_to_channel_message_event_id?: string\n  relay_url: string\n  content: string\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelHideMessageEventTemplate {\n  channel_message_event_id: string\n  content: string | { reason: string }\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelMuteUserEventTemplate {\n  content: string | { reason: string }\n  created_at: number\n  pubkey_to_mute: string\n  tags?: string[][]\n}\n\nexport const channelCreateEvent = (\n  t: ChannelCreateEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelCreation> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelCreation,\n      tags: [...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport const channelMetadataEvent = (\n  t: ChannelMetadataEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelMetadata> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelMetadata,\n      tags: [['e', t.channel_create_event_id], ...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport const channelMessageEvent = (t: ChannelMessageEventTemplate, privateKey: string): Event<Kind.ChannelMessage> => {\n  const tags = [['e', t.channel_create_event_id, t.relay_url, 'root']]\n\n  if (t.reply_to_channel_message_event_id) {\n    tags.push(['e', t.reply_to_channel_message_event_id, t.relay_url, 'reply'])\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelMessage,\n      tags: [...tags, ...(t.tags ?? [])],\n      content: t.content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\n/* \"e\" tag should be the kind 42 event to hide */\nexport const channelHideMessageEvent = (\n  t: ChannelHideMessageEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelHideMessage> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelHideMessage,\n      tags: [['e', t.channel_message_event_id], ...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport const channelMuteUserEvent = (\n  t: ChannelMuteUserEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelMuteUser> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelMuteUser,\n      tags: [['p', t.pubkey_to_mute], ...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n", "var _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function validateGithub(pubkey: string, username: string, proof: string): Promise<boolean> {\n  try {\n    let res = await (await _fetch(`https://gist.github.com/${username}/${proof}/raw`)).text()\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`\n  } catch (_) {\n    return false\n  }\n}\n", "import { Kind, type EventTemplate, type Event } from './event.ts'\nimport { Relay } from './relay.ts'\n\n/**\n * Authenticate via NIP-42 flow.\n *\n * @example\n * const sign = window.nostr.signEvent\n * relay.on('auth', challenge =>\n *   authenticate({ relay, sign, challenge })\n * )\n */\nexport const authenticate = async ({\n  challenge,\n  relay,\n  sign,\n}: {\n  challenge: string\n  relay: Relay\n  sign: <K extends number = number>(e: EventTemplate<K>) => Promise<Event<K>> | Event<K>\n}): Promise<void> => {\n  const e: EventTemplate = {\n    kind: Kind.ClientAuth,\n    created_at: Math.floor(Date.now() / 1000),\n    tags: [\n      ['relay', relay.url],\n      ['challenge', challenge],\n    ],\n    content: '',\n  }\n  return relay.auth(await sign(e))\n}\n", "import { chacha20 } from '@noble/ciphers/chacha'\nimport { ensureBytes, equalBytes } from '@noble/ciphers/utils'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { hkdf } from '@noble/hashes/hkdf'\nimport { hmac } from '@noble/hashes/hmac'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { concatBytes, randomBytes } from '@noble/hashes/utils'\nimport { base64 } from '@scure/base'\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nexport const utils = {\n  v2: {\n    maxPlaintextSize: 65536 - 128, // 64kb - 128\n    minCiphertextSize: 100, // should be 128 if min padded to 32b: base64(1+32+32+32)\n    maxCiphertextSize: 102400, // 100kb\n\n    getConversationKey(privkeyA: string, pubkeyB: string): Uint8Array {\n      const key = secp256k1.getSharedSecret(privkeyA, '02' + pubkeyB)\n      return key.subarray(1, 33)\n    },\n\n    getMessageKeys(conversationKey: Uint8Array, salt: Uint8Array) {\n      const keys = hkdf(sha256, conversationKey, salt, 'nip44-v2', 76)\n      return {\n        encryption: keys.subarray(0, 32),\n        nonce: keys.subarray(32, 44),\n        auth: keys.subarray(44, 76),\n      }\n    },\n\n    calcPadding(len: number): number {\n      if (!Number.isSafeInteger(len) || len < 0) throw new Error('expected positive integer')\n      if (len <= 32) return 32\n      const nextpower = 1 << (Math.floor(Math.log2(len - 1)) + 1)\n      const chunk = nextpower <= 256 ? 32 : nextpower / 8\n      return chunk * (Math.floor((len - 1) / chunk) + 1)\n    },\n\n    pad(unpadded: string): Uint8Array {\n      const unpaddedB = utf8Encoder.encode(unpadded)\n      const len = unpaddedB.length\n      if (len < 1 || len >= utils.v2.maxPlaintextSize) throw new Error('invalid plaintext length: must be between 1b and 64KB')\n      const paddedLen = utils.v2.calcPadding(len)\n      const zeros = new Uint8Array(paddedLen - len)\n      const lenBuf = new Uint8Array(2)\n      new DataView(lenBuf.buffer).setUint16(0, len)\n      return concatBytes(lenBuf, unpaddedB, zeros)\n    },\n\n    unpad(padded: Uint8Array): string {\n      const unpaddedLen = new DataView(padded.buffer).getUint16(0)\n      const unpadded = padded.subarray(2, 2 + unpaddedLen)\n      if (\n        unpaddedLen === 0 ||\n        unpadded.length !== unpaddedLen ||\n        padded.length !== 2 + utils.v2.calcPadding(unpaddedLen)\n      )\n        throw new Error('invalid padding')\n      return utf8Decoder.decode(unpadded)\n    },\n  },\n}\n\nexport function encrypt(\n  key: Uint8Array,\n  plaintext: string,\n  options: { salt?: Uint8Array; version?: number } = {},\n): string {\n  const version = options.version ?? 2\n  if (version !== 2) throw new Error('unknown encryption version ' + version)\n  const salt = options.salt ?? randomBytes(32)\n  ensureBytes(salt, 32)\n  const keys = utils.v2.getMessageKeys(key, salt)\n  const padded = utils.v2.pad(plaintext)\n  const ciphertext = chacha20(keys.encryption, keys.nonce, padded)\n  const mac = hmac(sha256, keys.auth, ciphertext)\n  return base64.encode(concatBytes(new Uint8Array([version]), salt, ciphertext, mac))\n}\n\nexport function decrypt(key: Uint8Array, ciphertext: string): string {\n  const u = utils.v2\n  ensureBytes(key, 32)\n\n  const clen = ciphertext.length\n  if (clen < u.minCiphertextSize || clen >= u.maxCiphertextSize) throw new Error('invalid ciphertext length: ' + clen)\n\n  if (ciphertext[0] === '#') throw new Error('unknown encryption version')\n  let data: Uint8Array\n  try {\n    data = base64.decode(ciphertext)\n  } catch (error) {\n    throw new Error('invalid base64: ' + (error as any).message)\n  }\n  const vers = data.subarray(0, 1)[0]\n  if (vers !== 2) throw new Error('unknown encryption version ' + vers)\n\n  const salt = data.subarray(1, 33)\n  const ciphertext_ = data.subarray(33, -32)\n  const mac = data.subarray(-32)\n\n  const keys = u.getMessageKeys(key, salt)\n  const calculatedMac = hmac(sha256, keys.auth, ciphertext_)\n  if (!equalBytes(calculatedMac, mac)) throw new Error('invalid MAC')\n\n  const padded = chacha20(keys.encryption, keys.nonce, ciphertext_)\n  return u.unpad(padded)\n}\n", "import { finishEvent } from './event.ts'\nimport { encrypt } from './nip04.ts'\nimport { Kind } from './event'\n\nexport function parseConnectionString(connectionString: string) {\n  const { pathname, searchParams } = new URL(connectionString)\n  const pubkey = pathname\n  const relay = searchParams.get('relay')\n  const secret = searchParams.get('secret')\n\n  if (!pubkey || !relay || !secret) {\n    throw new Error('invalid connection string')\n  }\n\n  return { pubkey, relay, secret }\n}\n\nexport async function makeNwcRequestEvent({\n  pubkey,\n  secret,\n  invoice,\n}: {\n  pubkey: string\n  secret: string\n  invoice: string\n}) {\n  const content = {\n    method: 'pay_invoice',\n    params: {\n      invoice,\n    },\n  }\n  const encryptedContent = await encrypt(secret, pubkey, JSON.stringify(content))\n  const eventTemplate = {\n    kind: Kind.NwcRequest,\n    created_at: Math.round(Date.now() / 1000),\n    content: encryptedContent,\n    tags: [['p', pubkey]],\n  }\n\n  return finishEvent(eventTemplate, secret)\n}\n", "import { bech32 } from '@scure/base'\n\nimport { Kind, validateEvent, verifySignature, type Event, type EventTemplate } from './event.ts'\nimport { utf8Decoder } from './utils.ts'\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function getZapEndpoint(metadata: Event<Kind.Metadata>): Promise<null | string> {\n  try {\n    let lnurl: string = ''\n    let { lud06, lud16 } = JSON.parse(metadata.content)\n    if (lud06) {\n      let { words } = bech32.decode(lud06, 1000)\n      let data = bech32.fromWords(words)\n      lnurl = utf8Decoder.decode(data)\n    } else if (lud16) {\n      let [name, domain] = lud16.split('@')\n      lnurl = `https://${domain}/.well-known/lnurlp/${name}`\n    } else {\n      return null\n    }\n\n    let res = await _fetch(lnurl)\n    let body = await res.json()\n\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback\n    }\n  } catch (err) {\n    /*-*/\n  }\n\n  return null\n}\n\nexport function makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = '',\n}: {\n  profile: string\n  event: string | null\n  amount: number\n  comment: string\n  relays: string[]\n}): EventTemplate<Kind.ZapRequest> {\n  if (!amount) throw new Error('amount not given')\n  if (!profile) throw new Error('profile not given')\n\n  let zr: EventTemplate<Kind.ZapRequest> = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1000),\n    content: comment,\n    tags: [\n      ['p', profile],\n      ['amount', amount.toString()],\n      ['relays', ...relays],\n    ],\n  }\n\n  if (event) {\n    zr.tags.push(['e', event])\n  }\n\n  return zr\n}\n\nexport function validateZapRequest(zapRequestString: string): string | null {\n  let zapRequest: Event\n\n  try {\n    zapRequest = JSON.parse(zapRequestString)\n  } catch (err) {\n    return 'Invalid zap request JSON.'\n  }\n\n  if (!validateEvent(zapRequest)) return 'Zap request is not a valid Nostr event.'\n\n  if (!verifySignature(zapRequest)) return 'Invalid signature on zap request.'\n\n  let p = zapRequest.tags.find(([t, v]) => t === 'p' && v)\n  if (!p) return \"Zap request doesn't have a 'p' tag.\"\n  if (!p[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'p' tag is not valid hex.\"\n\n  let e = zapRequest.tags.find(([t, v]) => t === 'e' && v)\n  if (e && !e[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'e' tag is not valid hex.\"\n\n  let relays = zapRequest.tags.find(([t, v]) => t === 'relays' && v)\n  if (!relays) return \"Zap request doesn't have a 'relays' tag.\"\n\n  return null\n}\n\nexport function makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt,\n}: {\n  zapRequest: string\n  preimage?: string\n  bolt11: string\n  paidAt: Date\n}): EventTemplate<Kind.Zap> {\n  let zr: Event<Kind.ZapRequest> = JSON.parse(zapRequest)\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === 'e' || t === 'p' || t === 'a')\n\n  let zap: EventTemplate<Kind.Zap> = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1000),\n    content: '',\n    tags: [...tagsFromZapRequest, ['bolt11', bolt11], ['description', zapRequest]],\n  }\n\n  if (preimage) {\n    zap.tags.push(['preimage', preimage])\n  }\n\n  return zap\n}\n", "import { base64 } from '@scure/base'\nimport { Event, EventTemplate, Kind, getBlankEvent, verifySignature } from './event'\nimport { utf8Decoder, utf8Encoder } from './utils'\n\nconst _authorizationScheme = 'Nostr '\n\n/**\n * Generate token for NIP-98 flow.\n *\n * @example\n * const sign = window.nostr.signEvent\n * await nip98.getToken('https://example.com/login', 'post', (e) => sign(e), true)\n */\nexport async function getToken(\n  loginUrl: string,\n  httpMethod: string,\n  sign: <K extends number = number>(e: EventTemplate<K>) => Promise<Event<K>> | Event<K>,\n  includeAuthorizationScheme: boolean = false,\n): Promise<string> {\n  if (!loginUrl || !httpMethod) throw new Error('Missing loginUrl or httpMethod')\n\n  const event = getBlankEvent(Kind.HttpAuth)\n\n  event.tags = [\n    ['u', loginUrl],\n    ['method', httpMethod],\n  ]\n  event.created_at = Math.round(new Date().getTime() / 1000)\n\n  const signedEvent = await sign(event)\n\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : ''\n  return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)))\n}\n\n/**\n * Validate token for NIP-98 flow.\n *\n * @example\n * await nip98.validateToken('Nostr base64token', 'https://example.com/login', 'post')\n */\nexport async function validateToken(token: string, url: string, method: string): Promise<boolean> {\n  const event = await unpackEventFromToken(token).catch(error => {\n    throw error\n  })\n  const valid = await validateEvent(event, url, method).catch(error => {\n    throw error\n  })\n\n  return valid\n}\n\nexport async function unpackEventFromToken(token: string): Promise<Event> {\n  if (!token) {\n    throw new Error('Missing token')\n  }\n  token = token.replace(_authorizationScheme, '')\n\n  const eventB64 = utf8Decoder.decode(base64.decode(token))\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith('{')) {\n    throw new Error('Invalid token')\n  }\n\n  const event = JSON.parse(eventB64) as Event\n\n  return event\n}\n\nexport async function validateEvent(event: Event, url: string, method: string): Promise<boolean> {\n  if (!event) {\n    throw new Error('Invalid nostr event')\n  }\n  if (!verifySignature(event)) {\n    throw new Error('Invalid nostr event, signature invalid')\n  }\n  if (event.kind !== Kind.HttpAuth) {\n    throw new Error('Invalid nostr event, kind invalid')\n  }\n\n  if (!event.created_at) {\n    throw new Error('Invalid nostr event, created_at invalid')\n  }\n\n  // Event must be less than 60 seconds old\n  if (Math.round(new Date().getTime() / 1000) - event.created_at > 60) {\n    throw new Error('Invalid nostr event, expired')\n  }\n\n  const urlTag = event.tags.find(t => t[0] === 'u')\n  if (urlTag?.length !== 1 && urlTag?.[1] !== url) {\n    throw new Error('Invalid nostr event, url tag invalid')\n  }\n\n  const methodTag = event.tags.find(t => t[0] === 'method')\n  if (methodTag?.length !== 1 && methodTag?.[1].toLowerCase() !== method.toLowerCase()) {\n    throw new Error('Invalid nostr event, method tag invalid')\n  }\n\n  return true\n}\n"],
  "mappings": "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",
  "names": ["schnorr", "bytesToHex", "Kind", "bytesToHex", "schnorr", "id", "resolve", "reject", "listeners", "filters", "opts", "batchKey", "relays", "bytesToHex", "bytesToHex", "bytesToHex", "parse", "parse", "schnorr", "bytesToHex", "sha256", "sha256", "bytesToHex", "schnorr", "tag", "useFetchImplementation", "_fetch", "decrypt", "encrypt", "secp256k1", "sha256", "concatBytes", "randomBytes", "base64", "secp256k1", "sha256", "concatBytes", "encrypt", "randomBytes", "base64", "decrypt", "useFetchImplementation", "bech32", "_fetch", "useFetchImplementation", "bech32", "validateEvent", "base64", "base64", "validateEvent"]
}

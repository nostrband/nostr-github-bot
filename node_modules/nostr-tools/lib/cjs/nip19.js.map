{
  "version": 3,
  "sources": ["../../nip19.ts", "../../utils.ts"],
  "sourcesContent": ["import { bytesToHex, concatBytes, hexToBytes } from '@noble/hashes/utils'\nimport { bech32 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nconst Bech32MaxSize = 5000\n\n/**\n * Bech32 regex.\n * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32\n */\nexport const BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/\n\nfunction integerToUint8Array(number: number) {\n  // Create a Uint8Array with enough space to hold a 32-bit integer (4 bytes).\n  const uint8Array = new Uint8Array(4)\n\n  // Use bitwise operations to extract the bytes.\n  uint8Array[0] = (number >> 24) & 0xff // Most significant byte (MSB)\n  uint8Array[1] = (number >> 16) & 0xff\n  uint8Array[2] = (number >> 8) & 0xff\n  uint8Array[3] = number & 0xff // Least significant byte (LSB)\n\n  return uint8Array\n}\n\nexport type ProfilePointer = {\n  pubkey: string // hex\n  relays?: string[]\n}\n\nexport type EventPointer = {\n  id: string // hex\n  relays?: string[]\n  author?: string\n  kind?: number\n}\n\nexport type AddressPointer = {\n  identifier: string\n  pubkey: string\n  kind: number\n  relays?: string[]\n}\n\ntype Prefixes = {\n  nprofile: ProfilePointer\n  nrelay: string\n  nevent: EventPointer\n  naddr: AddressPointer\n  nsec: string\n  npub: string\n  note: string\n}\n\ntype DecodeValue<Prefix extends keyof Prefixes> = {\n  type: Prefix\n  data: Prefixes[Prefix]\n}\n\nexport type DecodeResult = {\n  [P in keyof Prefixes]: DecodeValue<P>\n}[keyof Prefixes]\n\nexport function decode<Prefix extends keyof Prefixes>(nip19: `${Prefix}1${string}`): DecodeValue<Prefix>\nexport function decode(nip19: string): DecodeResult\nexport function decode(nip19: string): DecodeResult {\n  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize)\n  let data = new Uint8Array(bech32.fromWords(words))\n\n  switch (prefix) {\n    case 'nprofile': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nprofile')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n\n      return {\n        type: 'nprofile',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n    case 'nevent': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nevent')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (tlv[2] && tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (tlv[3] && tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'nevent',\n        data: {\n          id: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : undefined,\n          kind: tlv[3]?.[0] ? parseInt(bytesToHex(tlv[3][0]), 16) : undefined,\n        },\n      }\n    }\n\n    case 'naddr': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for naddr')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for naddr')\n      if (tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for naddr')\n      if (tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'naddr',\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: bytesToHex(tlv[2][0]),\n          kind: parseInt(bytesToHex(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n\n    case 'nrelay': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nrelay')\n\n      return {\n        type: 'nrelay',\n        data: utf8Decoder.decode(tlv[0][0]),\n      }\n    }\n\n    case 'nsec':\n    case 'npub':\n    case 'note':\n      return { type: prefix, data: bytesToHex(data) }\n\n    default:\n      throw new Error(`unknown prefix ${prefix}`)\n  }\n}\n\ntype TLV = { [t: number]: Uint8Array[] }\n\nfunction parseTLV(data: Uint8Array): TLV {\n  let result: TLV = {}\n  let rest = data\n  while (rest.length > 0) {\n    let t = rest[0]\n    let l = rest[1]\n    if (!l) throw new Error(`malformed TLV ${t}`)\n    let v = rest.slice(2, 2 + l)\n    rest = rest.slice(2 + l)\n    if (v.length < l) throw new Error(`not enough data to read on TLV ${t}`)\n    result[t] = result[t] || []\n    result[t].push(v)\n  }\n  return result\n}\n\nexport function nsecEncode(hex: string): `nsec1${string}` {\n  return encodeBytes('nsec', hex)\n}\n\nexport function npubEncode(hex: string): `npub1${string}` {\n  return encodeBytes('npub', hex)\n}\n\nexport function noteEncode(hex: string): `note1${string}` {\n  return encodeBytes('note', hex)\n}\n\nfunction encodeBech32<Prefix extends string>(prefix: Prefix, data: Uint8Array): `${Prefix}1${string}` {\n  let words = bech32.toWords(data)\n  return bech32.encode(prefix, words, Bech32MaxSize) as `${Prefix}1${string}`\n}\n\nfunction encodeBytes<Prefix extends string>(prefix: Prefix, hex: string): `${Prefix}1${string}` {\n  let data = hexToBytes(hex)\n  return encodeBech32(prefix, data)\n}\n\nexport function nprofileEncode(profile: ProfilePointer): `nprofile1${string}` {\n  let data = encodeTLV({\n    0: [hexToBytes(profile.pubkey)],\n    1: (profile.relays || []).map(url => utf8Encoder.encode(url)),\n  })\n  return encodeBech32('nprofile', data)\n}\n\nexport function neventEncode(event: EventPointer): `nevent1${string}` {\n  let kindArray\n  if (event.kind != undefined) {\n    kindArray = integerToUint8Array(event.kind)\n  }\n\n  let data = encodeTLV({\n    0: [hexToBytes(event.id)],\n    1: (event.relays || []).map(url => utf8Encoder.encode(url)),\n    2: event.author ? [hexToBytes(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : [],\n  })\n\n  return encodeBech32('nevent', data)\n}\n\nexport function naddrEncode(addr: AddressPointer): `naddr1${string}` {\n  let kind = new ArrayBuffer(4)\n  new DataView(kind).setUint32(0, addr.kind, false)\n\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map(url => utf8Encoder.encode(url)),\n    2: [hexToBytes(addr.pubkey)],\n    3: [new Uint8Array(kind)],\n  })\n  return encodeBech32('naddr', data)\n}\n\nexport function nrelayEncode(url: string): `nrelay1${string}` {\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(url)],\n  })\n  return encodeBech32('nrelay', data)\n}\n\nfunction encodeTLV(tlv: TLV): Uint8Array {\n  let entries: Uint8Array[] = []\n\n  Object.entries(tlv).forEach(([t, vs]) => {\n    vs.forEach(v => {\n      let entry = new Uint8Array(v.length + 2)\n      entry.set([parseInt(t)], 0)\n      entry.set([v.length], 1)\n      entry.set(v, 2)\n      entries.push(entry)\n    })\n  })\n\n  return concatBytes(...entries)\n}\n", "import type { Event } from './event.ts'\n\nexport const utf8Decoder = new TextDecoder('utf-8')\nexport const utf8Encoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\n//\n// fast insert-into-sorted-array functions adapted from https://github.com/terrymorse58/fast-sorted-array\n//\nexport function insertEventIntoDescendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport class MessageNode {\n  private _value: string\n  private _next: MessageNode | null\n\n  public get value(): string {\n    return this._value\n  }\n  public set value(message: string) {\n    this._value = message\n  }\n  public get next(): MessageNode | null {\n    return this._next\n  }\n  public set next(node: MessageNode | null) {\n    this._next = node\n  }\n\n  constructor(message: string) {\n    this._value = message\n    this._next = null\n  }\n}\n\nexport class MessageQueue {\n  private _first: MessageNode | null\n  private _last: MessageNode | null\n\n  public get first(): MessageNode | null {\n    return this._first\n  }\n  public set first(messageNode: MessageNode | null) {\n    this._first = messageNode\n  }\n  public get last(): MessageNode | null {\n    return this._last\n  }\n  public set last(messageNode: MessageNode | null) {\n    this._last = messageNode\n  }\n  private _size: number\n  public get size(): number {\n    return this._size\n  }\n  public set size(v: number) {\n    this._size = v\n  }\n\n  constructor() {\n    this._first = null\n    this._last = null\n    this._size = 0\n  }\n  enqueue(message: string): boolean {\n    const newNode = new MessageNode(message)\n    if (this._size === 0 || !this._last) {\n      this._first = newNode\n      this._last = newNode\n    } else {\n      this._last.next = newNode\n      this._last = newNode\n    }\n    this._size++\n    return true\n  }\n  dequeue(): string | null {\n    if (this._size === 0 || !this._first) return null\n\n    let prev = this._first\n    this._first = prev.next\n    prev.next = null\n\n    this._size--\n    return prev.value\n  }\n}\n"],
  "mappings": "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",
  "names": []
}

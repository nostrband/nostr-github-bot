{
  "version": 3,
  "sources": ["../../nip26.ts", "../../utils.ts", "../../keys.ts"],
  "sourcesContent": ["import { schnorr } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@noble/hashes/utils'\nimport { sha256 } from '@noble/hashes/sha256'\n\nimport { utf8Encoder } from './utils.ts'\nimport { getPublicKey } from './keys.ts'\n\nimport type { Event } from './event.ts'\n\nexport type Parameters = {\n  pubkey: string // the key to whom the delegation will be given\n  kind?: number\n  until?: number // delegation will only be valid until this date\n  since?: number // delegation will be valid from this date on\n}\n\nexport type Delegation = {\n  from: string // the pubkey who signed the delegation\n  to: string // the pubkey that is allowed to use the delegation\n  cond: string // the string of conditions as they should be included in the event tag\n  sig: string\n}\n\nexport function createDelegation(privateKey: string, parameters: Parameters): Delegation {\n  let conditions = []\n  if ((parameters.kind || -1) >= 0) conditions.push(`kind=${parameters.kind}`)\n  if (parameters.until) conditions.push(`created_at<${parameters.until}`)\n  if (parameters.since) conditions.push(`created_at>${parameters.since}`)\n  let cond = conditions.join('&')\n\n  if (cond === '') throw new Error('refusing to create a delegation without any conditions')\n\n  let sighash = sha256(utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`))\n\n  let sig = bytesToHex(schnorr.sign(sighash, privateKey))\n\n  return {\n    from: getPublicKey(privateKey),\n    to: parameters.pubkey,\n    cond,\n    sig,\n  }\n}\n\nexport function getDelegator(event: Event<number>): string | null {\n  // find delegation tag\n  let tag = event.tags.find(tag => tag[0] === 'delegation' && tag.length >= 4)\n  if (!tag) return null\n\n  let pubkey = tag[1]\n  let cond = tag[2]\n  let sig = tag[3]\n\n  // check conditions\n  let conditions = cond.split('&')\n  for (let i = 0; i < conditions.length; i++) {\n    let [key, operator, value] = conditions[i].split(/\\b/)\n\n    // the supported conditions are just 'kind' and 'created_at' for now\n    if (key === 'kind' && operator === '=' && event.kind === parseInt(value)) continue\n    else if (key === 'created_at' && operator === '<' && event.created_at < parseInt(value)) continue\n    else if (key === 'created_at' && operator === '>' && event.created_at > parseInt(value)) continue\n    else return null // invalid condition\n  }\n\n  // check signature\n  let sighash = sha256(utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`))\n  if (!schnorr.verify(sig, sighash, pubkey)) return null\n\n  return pubkey\n}\n", "import type { Event } from './event.ts'\n\nexport const utf8Decoder = new TextDecoder('utf-8')\nexport const utf8Encoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\n//\n// fast insert-into-sorted-array functions adapted from https://github.com/terrymorse58/fast-sorted-array\n//\nexport function insertEventIntoDescendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport class MessageNode {\n  private _value: string\n  private _next: MessageNode | null\n\n  public get value(): string {\n    return this._value\n  }\n  public set value(message: string) {\n    this._value = message\n  }\n  public get next(): MessageNode | null {\n    return this._next\n  }\n  public set next(node: MessageNode | null) {\n    this._next = node\n  }\n\n  constructor(message: string) {\n    this._value = message\n    this._next = null\n  }\n}\n\nexport class MessageQueue {\n  private _first: MessageNode | null\n  private _last: MessageNode | null\n\n  public get first(): MessageNode | null {\n    return this._first\n  }\n  public set first(messageNode: MessageNode | null) {\n    this._first = messageNode\n  }\n  public get last(): MessageNode | null {\n    return this._last\n  }\n  public set last(messageNode: MessageNode | null) {\n    this._last = messageNode\n  }\n  private _size: number\n  public get size(): number {\n    return this._size\n  }\n  public set size(v: number) {\n    this._size = v\n  }\n\n  constructor() {\n    this._first = null\n    this._last = null\n    this._size = 0\n  }\n  enqueue(message: string): boolean {\n    const newNode = new MessageNode(message)\n    if (this._size === 0 || !this._last) {\n      this._first = newNode\n      this._last = newNode\n    } else {\n      this._last.next = newNode\n      this._last = newNode\n    }\n    this._size++\n    return true\n  }\n  dequeue(): string | null {\n    if (this._size === 0 || !this._first) return null\n\n    let prev = this._first\n    this._first = prev.next\n    prev.next = null\n\n    this._size--\n    return prev.value\n  }\n}\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nexport function generatePrivateKey(): string {\n  return bytesToHex(schnorr.utils.randomPrivateKey())\n}\n\nexport function getPublicKey(privateKey: string): string {\n  return bytesToHex(schnorr.getPublicKey(privateKey))\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,oBAAwB;AACxB,IAAAC,gBAA2B;AAC3B,oBAAuB;;;ACAhB,IAAM,cAAc,IAAI,YAAY,OAAO;AAC3C,IAAM,cAAc,IAAI,YAAY;;;ACH3C,uBAAwB;AACxB,mBAA2B;AAMpB,SAAS,aAAa,YAA4B;AACvD,aAAO,yBAAW,yBAAQ,aAAa,UAAU,CAAC;AACpD;;;AFcO,SAAS,iBAAiB,YAAoB,YAAoC;AACvF,MAAI,aAAa,CAAC;AAClB,OAAK,WAAW,QAAQ,OAAO;AAAG,eAAW,KAAK,QAAQ,WAAW,MAAM;AAC3E,MAAI,WAAW;AAAO,eAAW,KAAK,cAAc,WAAW,OAAO;AACtE,MAAI,WAAW;AAAO,eAAW,KAAK,cAAc,WAAW,OAAO;AACtE,MAAI,OAAO,WAAW,KAAK,GAAG;AAE9B,MAAI,SAAS;AAAI,UAAM,IAAI,MAAM,wDAAwD;AAEzF,MAAI,cAAU,sBAAO,YAAY,OAAO,oBAAoB,WAAW,UAAU,MAAM,CAAC;AAExF,MAAI,UAAM,0BAAW,0BAAQ,KAAK,SAAS,UAAU,CAAC;AAEtD,SAAO;AAAA,IACL,MAAM,aAAa,UAAU;AAAA,IAC7B,IAAI,WAAW;AAAA,IACf;AAAA,IACA;AAAA,EACF;AACF;AAEO,SAAS,aAAa,OAAqC;AAEhE,MAAI,MAAM,MAAM,KAAK,KAAK,CAAAC,SAAOA,KAAI,OAAO,gBAAgBA,KAAI,UAAU,CAAC;AAC3E,MAAI,CAAC;AAAK,WAAO;AAEjB,MAAI,SAAS,IAAI;AACjB,MAAI,OAAO,IAAI;AACf,MAAI,MAAM,IAAI;AAGd,MAAI,aAAa,KAAK,MAAM,GAAG;AAC/B,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,QAAI,CAAC,KAAK,UAAU,KAAK,IAAI,WAAW,GAAG,MAAM,IAAI;AAGrD,QAAI,QAAQ,UAAU,aAAa,OAAO,MAAM,SAAS,SAAS,KAAK;AAAG;AAAA,aACjE,QAAQ,gBAAgB,aAAa,OAAO,MAAM,aAAa,SAAS,KAAK;AAAG;AAAA,aAChF,QAAQ,gBAAgB,aAAa,OAAO,MAAM,aAAa,SAAS,KAAK;AAAG;AAAA;AACpF,aAAO;AAAA,EACd;AAGA,MAAI,cAAU,sBAAO,YAAY,OAAO,oBAAoB,MAAM,UAAU,MAAM,CAAC;AACnF,MAAI,CAAC,0BAAQ,OAAO,KAAK,SAAS,MAAM;AAAG,WAAO;AAElD,SAAO;AACT;",
  "names": ["import_secp256k1", "import_utils", "tag"]
}

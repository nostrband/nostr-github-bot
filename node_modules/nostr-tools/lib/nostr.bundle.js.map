{
  "version": 3,
  "sources": ["../index.ts", "../node_modules/@noble/hashes/src/_assert.ts", "../node_modules/@noble/hashes/src/crypto.ts", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/_sha2.ts", "../node_modules/@noble/hashes/src/sha256.ts", "../node_modules/@noble/curves/src/abstract/utils.ts", "../node_modules/@noble/curves/src/abstract/modular.ts", "../node_modules/@noble/curves/src/abstract/curve.ts", "../node_modules/@noble/curves/src/abstract/weierstrass.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../node_modules/@noble/curves/src/_shortw_utils.ts", "../node_modules/@noble/curves/src/secp256k1.ts", "../keys.ts", "../utils.ts", "../event.ts", "../filter.ts", "../fakejson.ts", "../relay.ts", "../pool.ts", "../nip19.ts", "../node_modules/@scure/base/lib/esm/index.js", "../references.ts", "../nip04.ts", "../nip05.ts", "../nip06.ts", "../node_modules/@scure/bip39/src/wordlists/english.ts", "../node_modules/@noble/hashes/src/pbkdf2.ts", "../node_modules/@noble/hashes/src/_u64.ts", "../node_modules/@noble/hashes/src/sha512.ts", "../node_modules/@scure/bip39/src/index.ts", "../node_modules/@noble/hashes/src/ripemd160.ts", "../node_modules/@scure/bip32/index.ts", "../nip10.ts", "../nip13.ts", "../nip18.ts", "../nip21.ts", "../nip25.ts", "../nip26.ts", "../nip27.ts", "../nip28.ts", "../nip39.ts", "../nip42.ts", "../nip44.ts", "../node_modules/@noble/ciphers/src/utils.ts", "../node_modules/@noble/ciphers/src/_assert.ts", "../node_modules/@noble/ciphers/src/_poly1305.ts", "../node_modules/@noble/ciphers/src/_salsa.ts", "../node_modules/@noble/ciphers/src/chacha.ts", "../node_modules/@noble/hashes/src/hkdf.ts", "../nip47.ts", "../nip57.ts", "../nip98.ts"],
  "sourcesContent": ["export * from './keys.ts'\nexport * from './relay.ts'\nexport * from './event.ts'\nexport * from './filter.ts'\nexport * from './pool.ts'\nexport * from './references.ts'\n\nexport * as nip04 from './nip04.ts'\nexport * as nip05 from './nip05.ts'\nexport * as nip06 from './nip06.ts'\nexport * as nip10 from './nip10.ts'\nexport * as nip13 from './nip13.ts'\nexport * as nip18 from './nip18.ts'\nexport * as nip19 from './nip19.ts'\nexport * as nip21 from './nip21.ts'\nexport * as nip25 from './nip25.ts'\nexport * as nip26 from './nip26.ts'\nexport * as nip27 from './nip27.ts'\nexport * as nip28 from './nip28.ts'\nexport * as nip39 from './nip39.ts'\nexport * as nip42 from './nip42.ts'\nexport * as nip44 from './nip44.ts'\nexport * as nip47 from './nip47.ts'\nexport * as nip57 from './nip57.ts'\nexport * as nip98 from './nip98.ts'\n\nexport * as fj from './fakejson.ts'\nexport * as utils from './utils.ts'\n", "export function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nexport function bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nexport function bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nexport function hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nexport function exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexport function output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output,\n};\n\nexport default assert;\n", "// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import assert from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    assert.exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\nexport const sha224 = wrapConstructor(() => new SHA224());\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) \u2261 1    if a is a square (mod p)\n  // (a | p) \u2261 -1   if a is not a square (mod p)\n  // (a | p) \u2261 0    if a \u2261 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) \u2261 -1 and set c \u2261 zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be \u2261 -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P \u2261 3 (mod 4)\n  // \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q \u2261 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P \u2261 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime, Fp2 for example has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n// 0 is non-invertible: non-batched version will throw on 0\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. curveFn.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  const constTimeNegate = (condition: boolean, item: T): T => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = (W: number) => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint) {\n      let p = c.ZERO;\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n     * - \uD835\uDC4A is the window size\n     * - \uD835\uDC5B is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = opts(W);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = opts(W);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      // @ts-ignore\n      const W: number = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    },\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y\u00B2 = x\u00B3 + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | true;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\n    const { Err: E } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\n      throw new E('Invalid signature integer: unnecessary leading zero');\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return { r, s };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n    const h = (num: number | bigint) => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>) {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y\u00B2 = x\u00B3 + ax + b: Short weierstrass curve formula\n   * @returns y\u00B2\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num: bigint) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) \u220B (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(readonly px: T, readonly py: T, readonly pz: T) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      // Zero is valid point too!\n      if (this.is0()) {\n        if (CURVE.allowInfinityPoint) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const { x, y } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y\u00B2\n      const right = weierstrassEquation(x); // x\u00B3 + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    private is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n: bigint): Point {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const { endo } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n\n      // Apply endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      assertGE(scalar);\n      let n = scalar;\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const { endo } = CURVE;\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) \u220B (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      const { px: x, py: y, pz: z } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num: bigint): boolean {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y\u00B2 = x\u00B3 + ax + b\n        let y = Fp.sqrt(y2); // y = y\u00B2 ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        throw new Error(\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(readonly r: bigint, readonly s: bigint, readonly recovery?: number) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size (nBitLength+64)\n     * as per FIPS 186 B.4.1 with modulo bias being neglible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const rand = CURVE.randomBytes(Fp.BYTES + 8);\n      const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);\n      return ut.numberToBytesBE(num, CURVE.nByteLength);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK))\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e, Fp.BYTES)); // check for being of size BYTES\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b \u2208 [1,q\u22121] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G \u00D7 k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1\u22C5G - U2\u22C5P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const { lowS, prehash } = opts;\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const { r, s } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if ((error as Error).message === 'PARSE')\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1\u22C5G + u2\u22C5P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * From draft-irtf-cfrg-hash-to-curve-16\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n", "import assert from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assert.hash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assert.exists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.bytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass, CurveType } from './abstract/weierstrass.js';\nimport { CHash } from './abstract/utils.js';\n\n// connects noble-curves to noble-hashes\nexport function getHash(hash: CHash) {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n// Same API as @noble/hashes, with ability to create curve with custom hash\ntype CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport function createCurve(curveDef: CurveDef, defHash: CHash) {\n  const create = (hash: CHash) => weierstrass({ ...curveDef, ...getHash(hash) });\n  return Object.freeze({ ...create(defHash), create });\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { ProjPointType as PointType, mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * \u221An = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\nexport const secp256k1 = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'\u22C5G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x \u2265 p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x\u00B3 + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'\u2265n. Ret bytes(d'\u22C5G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'\u22C5G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r \u2265 p.\n    if (!fe(r)) return false;\n    const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s \u2265 n.\n    if (!ge(s)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = s\u22C5G - e\u22C5P\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) \u2260 r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const schnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fp,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fp.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nexport function generatePrivateKey(): string {\n  return bytesToHex(schnorr.utils.randomPrivateKey())\n}\n\nexport function getPublicKey(privateKey: string): string {\n  return bytesToHex(schnorr.getPublicKey(privateKey))\n}\n", "import type { Event } from './event.ts'\n\nexport const utf8Decoder = new TextDecoder('utf-8')\nexport const utf8Encoder = new TextEncoder()\n\nexport function normalizeURL(url: string): string {\n  let p = new URL(url)\n  p.pathname = p.pathname.replace(/\\/+/g, '/')\n  if (p.pathname.endsWith('/')) p.pathname = p.pathname.slice(0, -1)\n  if ((p.port === '80' && p.protocol === 'ws:') || (p.port === '443' && p.protocol === 'wss:')) p.port = ''\n  p.searchParams.sort()\n  p.hash = ''\n  return p.toString()\n}\n\n//\n// fast insert-into-sorted-array functions adapted from https://github.com/terrymorse58/fast-sorted-array\n//\nexport function insertEventIntoDescendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport function insertEventIntoAscendingList(sortedArray: Event<number>[], event: Event<number>) {\n  let start = 0\n  let end = sortedArray.length - 1\n  let midPoint\n  let position = start\n\n  if (end < 0) {\n    position = 0\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end\n        break\n      }\n      midPoint = Math.floor(start + (end - start) / 2)\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint\n      } else {\n        // aMidPoint === num\n        position = midPoint\n        break\n      }\n    }\n\n  // insert when num is NOT already in (no duplicates)\n  if (sortedArray[position]?.id !== event.id) {\n    return [...sortedArray.slice(0, position), event, ...sortedArray.slice(position)]\n  }\n\n  return sortedArray\n}\n\nexport class MessageNode {\n  private _value: string\n  private _next: MessageNode | null\n\n  public get value(): string {\n    return this._value\n  }\n  public set value(message: string) {\n    this._value = message\n  }\n  public get next(): MessageNode | null {\n    return this._next\n  }\n  public set next(node: MessageNode | null) {\n    this._next = node\n  }\n\n  constructor(message: string) {\n    this._value = message\n    this._next = null\n  }\n}\n\nexport class MessageQueue {\n  private _first: MessageNode | null\n  private _last: MessageNode | null\n\n  public get first(): MessageNode | null {\n    return this._first\n  }\n  public set first(messageNode: MessageNode | null) {\n    this._first = messageNode\n  }\n  public get last(): MessageNode | null {\n    return this._last\n  }\n  public set last(messageNode: MessageNode | null) {\n    this._last = messageNode\n  }\n  private _size: number\n  public get size(): number {\n    return this._size\n  }\n  public set size(v: number) {\n    this._size = v\n  }\n\n  constructor() {\n    this._first = null\n    this._last = null\n    this._size = 0\n  }\n  enqueue(message: string): boolean {\n    const newNode = new MessageNode(message)\n    if (this._size === 0 || !this._last) {\n      this._first = newNode\n      this._last = newNode\n    } else {\n      this._last.next = newNode\n      this._last = newNode\n    }\n    this._size++\n    return true\n  }\n  dequeue(): string | null {\n    if (this._size === 0 || !this._first) return null\n\n    let prev = this._first\n    this._first = prev.next\n    prev.next = null\n\n    this._size--\n    return prev.value\n  }\n}\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nimport { getPublicKey } from './keys.ts'\nimport { utf8Encoder } from './utils.ts'\n\n/** Designates a verified event signature. */\nexport const verifiedSymbol = Symbol('verified')\n\n/** @deprecated Use numbers instead. */\n/* eslint-disable no-unused-vars */\nexport enum Kind {\n  Metadata = 0,\n  Text = 1,\n  RecommendRelay = 2,\n  Contacts = 3,\n  EncryptedDirectMessage = 4,\n  EventDeletion = 5,\n  Repost = 6,\n  Reaction = 7,\n  BadgeAward = 8,\n  ChannelCreation = 40,\n  ChannelMetadata = 41,\n  ChannelMessage = 42,\n  ChannelHideMessage = 43,\n  ChannelMuteUser = 44,\n  Blank = 255,\n  Report = 1984,\n  ZapRequest = 9734,\n  Zap = 9735,\n  RelayList = 10002,\n  ClientAuth = 22242,\n  NwcRequest = 23194,\n  HttpAuth = 27235,\n  ProfileBadge = 30008,\n  BadgeDefinition = 30009,\n  Article = 30023,\n  FileMetadata = 1063,\n}\n\nexport interface Event<K extends number = number> {\n  kind: K\n  tags: string[][]\n  content: string\n  created_at: number\n  pubkey: string\n  id: string\n  sig: string\n  [verifiedSymbol]?: boolean\n}\n\nexport type EventTemplate<K extends number = number> = Pick<Event<K>, 'kind' | 'tags' | 'content' | 'created_at'>\nexport type UnsignedEvent<K extends number = number> = Pick<\n  Event<K>,\n  'kind' | 'tags' | 'content' | 'created_at' | 'pubkey'\n>\n\n/** An event whose signature has been verified. */\nexport interface VerifiedEvent<K extends number = number> extends Event<K> {\n  [verifiedSymbol]: true\n}\n\nexport function getBlankEvent(): EventTemplate<Kind.Blank>\nexport function getBlankEvent<K extends number>(kind: K): EventTemplate<K>\nexport function getBlankEvent<K>(kind: K | Kind.Blank = Kind.Blank) {\n  return {\n    kind,\n    content: '',\n    tags: [],\n    created_at: 0,\n  }\n}\n\nexport function finishEvent<K extends number = number>(t: EventTemplate<K>, privateKey: string): VerifiedEvent<K> {\n  const event = t as VerifiedEvent<K>\n  event.pubkey = getPublicKey(privateKey)\n  event.id = getEventHash(event)\n  event.sig = getSignature(event, privateKey)\n  event[verifiedSymbol] = true\n  return event\n}\n\nexport function serializeEvent(evt: UnsignedEvent<number>): string {\n  if (!validateEvent(evt)) throw new Error(\"can't serialize event with wrong or missing properties\")\n\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])\n}\n\nexport function getEventHash(event: UnsignedEvent<number>): string {\n  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)))\n  return bytesToHex(eventHash)\n}\n\nconst isRecord = (obj: unknown): obj is Record<string, unknown> => obj instanceof Object\n\nexport function validateEvent<T>(event: T): event is T & UnsignedEvent<number> {\n  if (!isRecord(event)) return false\n  if (typeof event.kind !== 'number') return false\n  if (typeof event.content !== 'string') return false\n  if (typeof event.created_at !== 'number') return false\n  if (typeof event.pubkey !== 'string') return false\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false\n\n  if (!Array.isArray(event.tags)) return false\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i]\n    if (!Array.isArray(tag)) return false\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === 'object') return false\n    }\n  }\n\n  return true\n}\n\n/** Verify the event's signature. This function mutates the event with a `verified` symbol, making it idempotent. */\nexport function verifySignature<K extends number>(event: Event<K>): event is VerifiedEvent<K> {\n  if (typeof event[verifiedSymbol] === 'boolean') return event[verifiedSymbol]\n\n  const hash = getEventHash(event)\n  if (hash !== event.id) {\n    return (event[verifiedSymbol] = false)\n  }\n\n  try {\n    return (event[verifiedSymbol] = schnorr.verify(event.sig, hash, event.pubkey))\n  } catch (err) {\n    return (event[verifiedSymbol] = false)\n  }\n}\n\n/** @deprecated Use `getSignature` instead. */\nexport function signEvent(event: UnsignedEvent<number>, key: string): string {\n  console.warn(\n    'nostr-tools: `signEvent` is deprecated and will be removed or changed in the future. Please use `getSignature` instead.',\n  )\n  return getSignature(event, key)\n}\n\n/** Calculate the signature for an event. */\nexport function getSignature(event: UnsignedEvent<number>, key: string): string {\n  return bytesToHex(schnorr.sign(getEventHash(event), key))\n}\n", "import { Event } from './event.ts'\n\nexport type Filter<K extends number = number> = {\n  ids?: string[]\n  kinds?: K[]\n  authors?: string[]\n  since?: number\n  until?: number\n  limit?: number\n  search?: string\n  [key: `#${string}`]: string[] | undefined\n}\n\nexport function matchFilter(filter: Filter<number>, event: Event<number>): boolean {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    if (!filter.ids.some(prefix => event.id.startsWith(prefix))) {\n      return false\n    }\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    if (!filter.authors.some(prefix => event.pubkey.startsWith(prefix))) {\n      return false\n    }\n  }\n\n  for (let f in filter) {\n    if (f[0] === '#') {\n      let tagName = f.slice(1)\n      let values = filter[`#${tagName}`]\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values!.indexOf(v) !== -1)) return false\n    }\n  }\n\n  if (filter.since && event.created_at < filter.since) return false\n  if (filter.until && event.created_at > filter.until) return false\n\n  return true\n}\n\nexport function matchFilters(filters: Filter<number>[], event: Event<number>): boolean {\n  for (let i = 0; i < filters.length; i++) {\n    if (matchFilter(filters[i], event)) return true\n  }\n  return false\n}\n\nexport function mergeFilters(...filters: Filter<number>[]): Filter<number> {\n  let result: Filter<number> = {}\n  for (let i = 0; i < filters.length; i++) {\n    let filter = filters[i]\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === 'kinds' || property === 'ids' || property === 'authors' || property[0] === '#') {\n        // @ts-ignore\n        result[property] = result[property] || []\n        // @ts-ignore\n        for (let v = 0; v < values.length; v++) {\n          // @ts-ignore\n          let value = values[v]\n          // @ts-ignore\n          if (!result[property].includes(value)) result[property].push(value)\n        }\n      }\n    })\n\n    if (filter.limit && (!result.limit || filter.limit > result.limit)) result.limit = filter.limit\n    if (filter.until && (!result.until || filter.until > result.until)) result.until = filter.until\n    if (filter.since && (!result.since || filter.since < result.since)) result.since = filter.since\n  }\n\n  return result\n}\n", "export function getHex64(json: string, field: string): string {\n  let len = field.length + 3\n  let idx = json.indexOf(`\"${field}\":`) + len\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1\n  return json.slice(s, s + 64)\n}\n\nexport function getInt(json: string, field: string): number {\n  let len = field.length\n  let idx = json.indexOf(`\"${field}\":`) + len + 3\n  let sliced = json.slice(idx)\n  let end = Math.min(sliced.indexOf(','), sliced.indexOf('}'))\n  return parseInt(sliced.slice(0, end), 10)\n}\n\nexport function getSubscriptionId(json: string): string | null {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`)\n  if (idx === -1) return null\n\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`)\n  if (pstart === -1) return null\n  let start = idx + 7 + 1 + pstart\n\n  let pend = json.slice(start + 1, 80).indexOf(`\"`)\n  if (pend === -1) return null\n  let end = start + 1 + pend\n\n  return json.slice(start + 1, end)\n}\n\nexport function matchEventId(json: string, id: string): boolean {\n  return id === getHex64(json, 'id')\n}\n\nexport function matchEventPubkey(json: string, pubkey: string): boolean {\n  return pubkey === getHex64(json, 'pubkey')\n}\n\nexport function matchEventKind(json: string, kind: number): boolean {\n  return kind === getInt(json, 'kind')\n}\n", "/* global WebSocket */\n\nimport { verifySignature, validateEvent, type Event } from './event.ts'\nimport { matchFilters, type Filter } from './filter.ts'\nimport { getHex64, getSubscriptionId } from './fakejson.ts'\nimport { MessageQueue } from './utils.ts'\n\ntype RelayEvent = {\n  connect: () => void | Promise<void>\n  disconnect: () => void | Promise<void>\n  error: () => void | Promise<void>\n  notice: (msg: string) => void | Promise<void>\n  auth: (challenge: string) => void | Promise<void>\n}\nexport type CountPayload = {\n  count: number\n}\nexport type SubEvent<K extends number> = {\n  event: (event: Event<K>) => void | Promise<void>\n  count: (payload: CountPayload) => void | Promise<void>\n  eose: () => void | Promise<void>\n}\nexport type Relay = {\n  url: string\n  status: number\n  connect: () => Promise<void>\n  close: () => void\n  sub: <K extends number = number>(filters: Filter<K>[], opts?: SubscriptionOptions) => Sub<K>\n  list: <K extends number = number>(filters: Filter<K>[], opts?: SubscriptionOptions) => Promise<Event<K>[]>\n  get: <K extends number = number>(filter: Filter<K>, opts?: SubscriptionOptions) => Promise<Event<K> | null>\n  count: (filters: Filter[], opts?: SubscriptionOptions) => Promise<CountPayload | null>\n  publish: (event: Event<number>) => Promise<void>\n  auth: (event: Event<number>) => Promise<void>\n  off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(event: T, listener: U) => void\n  on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(event: T, listener: U) => void\n}\nexport type Sub<K extends number = number> = {\n  sub: <K extends number = number>(filters: Filter<K>[], opts: SubscriptionOptions) => Sub<K>\n  unsub: () => void\n  on: <T extends keyof SubEvent<K>, U extends SubEvent<K>[T]>(event: T, listener: U) => void\n  off: <T extends keyof SubEvent<K>, U extends SubEvent<K>[T]>(event: T, listener: U) => void\n  events: AsyncGenerator<Event<K>, void, unknown>\n}\n\nexport type SubscriptionOptions = {\n  id?: string\n  verb?: 'REQ' | 'COUNT'\n  skipVerification?: boolean\n  alreadyHaveEvent?: null | ((id: string, relay: string) => boolean)\n  eoseSubTimeout?: number\n}\n\nconst newListeners = (): { [TK in keyof RelayEvent]: RelayEvent[TK][] } => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: [],\n})\n\nexport function relayInit(\n  url: string,\n  options: {\n    getTimeout?: number\n    listTimeout?: number\n    countTimeout?: number\n  } = {},\n): Relay {\n  let { listTimeout = 3000, getTimeout = 3000, countTimeout = 3000 } = options\n\n  var ws: WebSocket\n  var openSubs: { [id: string]: { filters: Filter[] } & SubscriptionOptions } = {}\n  var listeners = newListeners()\n  var subListeners: {\n    [subid: string]: { [TK in keyof SubEvent<any>]: SubEvent<any>[TK][] }\n  } = {}\n  var pubListeners: {\n    [eventid: string]: {\n      resolve: (_: unknown) => void\n      reject: (err: Error) => void\n    }\n  } = {}\n\n  var connectionPromise: Promise<void> | undefined\n  async function connectRelay(): Promise<void> {\n    if (connectionPromise) return connectionPromise\n    connectionPromise = new Promise((resolve, reject) => {\n      try {\n        ws = new WebSocket(url)\n      } catch (err) {\n        reject(err)\n      }\n\n      ws.onopen = () => {\n        listeners.connect.forEach(cb => cb())\n        resolve()\n      }\n      ws.onerror = () => {\n        connectionPromise = undefined\n        listeners.error.forEach(cb => cb())\n        reject()\n      }\n      ws.onclose = async () => {\n        connectionPromise = undefined\n        listeners.disconnect.forEach(cb => cb())\n      }\n\n      let incomingMessageQueue: MessageQueue = new MessageQueue()\n      let handleNextInterval: any\n\n      ws.onmessage = e => {\n        incomingMessageQueue.enqueue(e.data)\n        if (!handleNextInterval) {\n          handleNextInterval = setInterval(handleNext, 0)\n        }\n      }\n\n      function handleNext() {\n        if (incomingMessageQueue.size === 0) {\n          clearInterval(handleNextInterval)\n          handleNextInterval = null\n          return\n        }\n\n        var json = incomingMessageQueue.dequeue()\n        if (!json) return\n\n        let subid = getSubscriptionId(json)\n        if (subid) {\n          let so = openSubs[subid]\n          if (so && so.alreadyHaveEvent && so.alreadyHaveEvent(getHex64(json, 'id'), url)) {\n            return\n          }\n        }\n\n        try {\n          let data = JSON.parse(json)\n\n          // we won't do any checks against the data since all failures (i.e. invalid messages from relays)\n          // will naturally be caught by the encompassing try..catch block\n\n          switch (data[0]) {\n            case 'EVENT': {\n              let id = data[1]\n              let event = data[2]\n              if (\n                validateEvent(event) &&\n                openSubs[id] &&\n                (openSubs[id].skipVerification || verifySignature(event)) &&\n                matchFilters(openSubs[id].filters, event)\n              ) {\n                openSubs[id]\n                ;(subListeners[id]?.event || []).forEach(cb => cb(event))\n              }\n              return\n            }\n            case 'COUNT':\n              let id = data[1]\n              let payload = data[2]\n              if (openSubs[id]) {\n                ;(subListeners[id]?.count || []).forEach(cb => cb(payload))\n              }\n              return\n            case 'EOSE': {\n              let id = data[1]\n              if (id in subListeners) {\n                subListeners[id].eose.forEach(cb => cb())\n                subListeners[id].eose = [] // 'eose' only happens once per sub, so stop listeners here\n              }\n              return\n            }\n            case 'OK': {\n              let id: string = data[1]\n              let ok: boolean = data[2]\n              let reason: string = data[3] || ''\n              if (id in pubListeners) {\n                let { resolve, reject } = pubListeners[id]\n                if (ok) resolve(null)\n                else reject(new Error(reason))\n              }\n              return\n            }\n            case 'NOTICE':\n              let notice = data[1]\n              listeners.notice.forEach(cb => cb(notice))\n              return\n            case 'AUTH': {\n              let challenge = data[1]\n              listeners.auth?.forEach(cb => cb(challenge))\n              return\n            }\n          }\n        } catch (err) {\n          return\n        }\n      }\n    })\n\n    return connectionPromise\n  }\n\n  function connected() {\n    return ws?.readyState === 1\n  }\n\n  async function connect(): Promise<void> {\n    if (connected()) return // ws already open\n    await connectRelay()\n  }\n\n  async function trySend(params: [string, ...any]) {\n    let msg = JSON.stringify(params)\n    if (!connected()) {\n      await new Promise(resolve => setTimeout(resolve, 1000))\n      if (!connected()) {\n        return\n      }\n    }\n    try {\n      ws.send(msg)\n    } catch (err) {\n      console.log(err)\n    }\n  }\n\n  const sub = <K extends number = number>(\n    filters: Filter<K>[],\n    {\n      verb = 'REQ',\n      skipVerification = false,\n      alreadyHaveEvent = null,\n      id = Math.random().toString().slice(2),\n    }: SubscriptionOptions = {},\n  ): Sub<K> => {\n    let subid = id\n\n    openSubs[subid] = {\n      id: subid,\n      filters,\n      skipVerification,\n      alreadyHaveEvent,\n    }\n    trySend([verb, subid, ...filters])\n\n    let subscription: Sub<K> = {\n      sub: (newFilters, newOpts = {}) =>\n        sub(newFilters || filters, {\n          skipVerification: newOpts.skipVerification || skipVerification,\n          alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,\n          id: subid,\n        }),\n      unsub: () => {\n        delete openSubs[subid]\n        delete subListeners[subid]\n        trySend(['CLOSE', subid])\n      },\n      on: (type, cb) => {\n        subListeners[subid] = subListeners[subid] || {\n          event: [],\n          count: [],\n          eose: [],\n        }\n        subListeners[subid][type].push(cb)\n      },\n      off: (type, cb): void => {\n        let listeners = subListeners[subid]\n        let idx = listeners[type].indexOf(cb)\n        if (idx >= 0) listeners[type].splice(idx, 1)\n      },\n      get events() {\n        return eventsGenerator(subscription)\n      },\n    }\n\n    return subscription\n  }\n\n  function _publishEvent(event: Event<number>, type: string) {\n    return new Promise((resolve, reject) => {\n      if (!event.id) {\n        reject(new Error(`event ${event} has no id`))\n        return\n      }\n\n      let id = event.id\n      trySend([type, event])\n      pubListeners[id] = { resolve, reject }\n    })\n  }\n\n  return {\n    url,\n    sub,\n    on: <T extends keyof RelayEvent, U extends RelayEvent[T]>(type: T, cb: U): void => {\n      listeners[type].push(cb)\n      if (type === 'connect' && ws?.readyState === 1) {\n        // i would love to know why we need this\n        ;(cb as () => void)()\n      }\n    },\n    off: <T extends keyof RelayEvent, U extends RelayEvent[T]>(type: T, cb: U): void => {\n      let index = listeners[type].indexOf(cb)\n      if (index !== -1) listeners[type].splice(index, 1)\n    },\n    list: (filters, opts?: SubscriptionOptions) =>\n      new Promise(resolve => {\n        let s = sub(filters, opts)\n        let events: Event<any>[] = []\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(events)\n        }, listTimeout)\n        s.on('eose', () => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(events)\n        })\n        s.on('event', event => {\n          events.push(event)\n        })\n      }),\n    get: (filter, opts?: SubscriptionOptions) =>\n      new Promise(resolve => {\n        let s = sub([filter], opts)\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, getTimeout)\n        s.on('event', event => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    count: (filters: Filter[]): Promise<CountPayload | null> =>\n      new Promise(resolve => {\n        let s = sub(filters, { ...sub, verb: 'COUNT' })\n        let timeout = setTimeout(() => {\n          s.unsub()\n          resolve(null)\n        }, countTimeout)\n        s.on('count', (event: CountPayload) => {\n          s.unsub()\n          clearTimeout(timeout)\n          resolve(event)\n        })\n      }),\n    async publish(event): Promise<void> {\n      await _publishEvent(event, 'EVENT')\n    },\n    async auth(event): Promise<void> {\n      await _publishEvent(event, 'AUTH')\n    },\n    connect,\n    close(): void {\n      listeners = newListeners()\n      subListeners = {}\n      pubListeners = {}\n      if (ws?.readyState === WebSocket.OPEN) {\n        ws.close()\n      }\n    },\n    get status() {\n      return ws?.readyState ?? 3\n    },\n  }\n}\n\nexport async function* eventsGenerator<K extends number>(sub: Sub<K>): AsyncGenerator<Event<K>, void, unknown> {\n  let nextResolve: ((event: Event<K>) => void) | undefined\n  const eventQueue: Event<K>[] = []\n\n  const pushToQueue = (event: Event<K>) => {\n    if (nextResolve) {\n      nextResolve(event)\n      nextResolve = undefined\n    } else {\n      eventQueue.push(event)\n    }\n  }\n\n  sub.on('event', pushToQueue)\n\n  try {\n    while (true) {\n      if (eventQueue.length > 0) {\n        yield eventQueue.shift()!\n      } else {\n        const event = await new Promise<Event<K>>(resolve => {\n          nextResolve = resolve\n        })\n        yield event\n      }\n    }\n  } finally {\n    sub.off('event', pushToQueue)\n  }\n}\n", "import { eventsGenerator, relayInit, type Relay, type Sub, type SubscriptionOptions } from './relay.ts'\nimport { normalizeURL } from './utils.ts'\n\nimport type { Event } from './event.ts'\nimport { matchFilters, mergeFilters, type Filter } from './filter.ts'\n\ntype BatchedRequest = {\n  filters: Filter<any>[]\n  relays: string[]\n  resolve: (events: Event<any>[]) => void\n  events: Event<any>[]\n}\n\nexport class SimplePool {\n  private _conn: { [url: string]: Relay }\n  private _seenOn: { [id: string]: Set<string> } = {} // a map of all events we've seen in each relay\n  private batchedByKey: { [batchKey: string]: BatchedRequest[] } = {}\n\n  private eoseSubTimeout: number\n  private getTimeout: number\n  private seenOnEnabled: boolean = true\n  private batchInterval: number = 100\n\n  constructor(\n    options: {\n      eoseSubTimeout?: number\n      getTimeout?: number\n      seenOnEnabled?: boolean\n      batchInterval?: number\n    } = {},\n  ) {\n    this._conn = {}\n    this.eoseSubTimeout = options.eoseSubTimeout || 3400\n    this.getTimeout = options.getTimeout || 3400\n    this.seenOnEnabled = options.seenOnEnabled !== false\n    this.batchInterval = options.batchInterval || 100\n  }\n\n  close(relays: string[]): void {\n    relays.forEach(url => {\n      let relay = this._conn[normalizeURL(url)]\n      if (relay) relay.close()\n    })\n  }\n\n  async ensureRelay(url: string): Promise<Relay> {\n    const nm = normalizeURL(url)\n\n    if (!this._conn[nm]) {\n      this._conn[nm] = relayInit(nm, {\n        getTimeout: this.getTimeout * 0.9,\n        listTimeout: this.getTimeout * 0.9,\n      })\n    }\n\n    const relay = this._conn[nm]\n    await relay.connect()\n    return relay\n  }\n\n  sub<K extends number = number>(relays: string[], filters: Filter<K>[], opts?: SubscriptionOptions): Sub<K> {\n    let _knownIds: Set<string> = new Set()\n    let modifiedOpts = { ...(opts || {}) }\n    modifiedOpts.alreadyHaveEvent = (id, url) => {\n      if (opts?.alreadyHaveEvent?.(id, url)) {\n        return true\n      }\n      if (this.seenOnEnabled) {\n        let set = this._seenOn[id] || new Set()\n        set.add(url)\n        this._seenOn[id] = set\n      }\n      return _knownIds.has(id)\n    }\n\n    let subs: Sub[] = []\n    let eventListeners: Set<any> = new Set()\n    let eoseListeners: Set<() => void> = new Set()\n    let eosesMissing = relays.length\n\n    let eoseSent = false\n    let eoseTimeout = setTimeout(\n      () => {\n        eoseSent = true\n        for (let cb of eoseListeners.values()) cb()\n      },\n      opts?.eoseSubTimeout || this.eoseSubTimeout,\n    )\n\n    relays\n      .filter((r, i, a) => a.indexOf(r) === i)\n      .forEach(async relay => {\n        let r\n        try {\n          r = await this.ensureRelay(relay)\n        } catch (err) {\n          handleEose()\n          return\n        }\n        if (!r) return\n        let s = r.sub(filters, modifiedOpts)\n        s.on('event', event => {\n          _knownIds.add(event.id as string)\n          for (let cb of eventListeners.values()) cb(event)\n        })\n        s.on('eose', () => {\n          if (eoseSent) return\n          handleEose()\n        })\n        subs.push(s)\n\n        function handleEose() {\n          eosesMissing--\n          if (eosesMissing === 0) {\n            clearTimeout(eoseTimeout)\n            for (let cb of eoseListeners.values()) cb()\n          }\n        }\n      })\n\n    let greaterSub: Sub<K> = {\n      sub(filters, opts) {\n        subs.forEach(sub => sub.sub(filters, opts))\n        return greaterSub as any\n      },\n      unsub() {\n        subs.forEach(sub => sub.unsub())\n      },\n      on(type, cb) {\n        if (type === 'event') {\n          eventListeners.add(cb)\n        } else if (type === 'eose') {\n          eoseListeners.add(cb as () => void | Promise<void>)\n        }\n      },\n      off(type, cb) {\n        if (type === 'event') {\n          eventListeners.delete(cb)\n        } else if (type === 'eose') eoseListeners.delete(cb as () => void | Promise<void>)\n      },\n      get events() {\n        return eventsGenerator(greaterSub)\n      },\n    }\n\n    return greaterSub\n  }\n\n  get<K extends number = number>(\n    relays: string[],\n    filter: Filter<K>,\n    opts?: SubscriptionOptions,\n  ): Promise<Event<K> | null> {\n    return new Promise(resolve => {\n      let sub = this.sub(relays, [filter], opts)\n      let timeout = setTimeout(() => {\n        sub.unsub()\n        resolve(null)\n      }, this.getTimeout)\n      sub.on('event', event => {\n        resolve(event)\n        clearTimeout(timeout)\n        sub.unsub()\n      })\n    })\n  }\n\n  list<K extends number = number>(\n    relays: string[],\n    filters: Filter<K>[],\n    opts?: SubscriptionOptions,\n  ): Promise<Event<K>[]> {\n    return new Promise(resolve => {\n      let events: Event<K>[] = []\n      let sub = this.sub(relays, filters, opts)\n\n      sub.on('event', event => {\n        events.push(event)\n      })\n\n      // we can rely on an eose being emitted here because pool.sub() will fake one\n      sub.on('eose', () => {\n        sub.unsub()\n        resolve(events)\n      })\n    })\n  }\n\n  batchedList<K extends number = number>(\n    batchKey: string,\n    relays: string[],\n    filters: Filter<K>[],\n  ): Promise<Event<K>[]> {\n    return new Promise(resolve => {\n      if (!this.batchedByKey[batchKey]) {\n        this.batchedByKey[batchKey] = [\n          {\n            filters,\n            relays,\n            resolve,\n            events: [],\n          },\n        ]\n\n        setTimeout(() => {\n          Object.keys(this.batchedByKey).forEach(async batchKey => {\n            const batchedRequests = this.batchedByKey[batchKey]\n\n            const filters = [] as Filter[]\n            const relays = [] as string[]\n            batchedRequests.forEach(br => {\n              filters.push(...br.filters)\n              relays.push(...br.relays)\n            })\n\n            const sub = this.sub(relays, [mergeFilters(...filters)])\n            sub.on('event', event => {\n              batchedRequests.forEach(br => matchFilters(br.filters, event) && br.events.push(event))\n            })\n            sub.on('eose', () => {\n              sub.unsub()\n              batchedRequests.forEach(br => br.resolve(br.events))\n            })\n\n            delete this.batchedByKey[batchKey]\n          })\n        }, this.batchInterval)\n      } else {\n        this.batchedByKey[batchKey].push({\n          filters,\n          relays,\n          resolve,\n          events: [],\n        })\n      }\n    })\n  }\n\n  publish(relays: string[], event: Event<number>): Promise<void>[] {\n    return relays.map(async relay => {\n      let r = await this.ensureRelay(relay)\n      return r.publish(event)\n    })\n  }\n\n  seenOn(id: string): string[] {\n    return Array.from(this._seenOn[id]?.values?.() || [])\n  }\n}\n", "import { bytesToHex, concatBytes, hexToBytes } from '@noble/hashes/utils'\nimport { bech32 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nconst Bech32MaxSize = 5000\n\n/**\n * Bech32 regex.\n * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32\n */\nexport const BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/\n\nfunction integerToUint8Array(number: number) {\n  // Create a Uint8Array with enough space to hold a 32-bit integer (4 bytes).\n  const uint8Array = new Uint8Array(4)\n\n  // Use bitwise operations to extract the bytes.\n  uint8Array[0] = (number >> 24) & 0xff // Most significant byte (MSB)\n  uint8Array[1] = (number >> 16) & 0xff\n  uint8Array[2] = (number >> 8) & 0xff\n  uint8Array[3] = number & 0xff // Least significant byte (LSB)\n\n  return uint8Array\n}\n\nexport type ProfilePointer = {\n  pubkey: string // hex\n  relays?: string[]\n}\n\nexport type EventPointer = {\n  id: string // hex\n  relays?: string[]\n  author?: string\n  kind?: number\n}\n\nexport type AddressPointer = {\n  identifier: string\n  pubkey: string\n  kind: number\n  relays?: string[]\n}\n\ntype Prefixes = {\n  nprofile: ProfilePointer\n  nrelay: string\n  nevent: EventPointer\n  naddr: AddressPointer\n  nsec: string\n  npub: string\n  note: string\n}\n\ntype DecodeValue<Prefix extends keyof Prefixes> = {\n  type: Prefix\n  data: Prefixes[Prefix]\n}\n\nexport type DecodeResult = {\n  [P in keyof Prefixes]: DecodeValue<P>\n}[keyof Prefixes]\n\nexport function decode<Prefix extends keyof Prefixes>(nip19: `${Prefix}1${string}`): DecodeValue<Prefix>\nexport function decode(nip19: string): DecodeResult\nexport function decode(nip19: string): DecodeResult {\n  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize)\n  let data = new Uint8Array(bech32.fromWords(words))\n\n  switch (prefix) {\n    case 'nprofile': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nprofile')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n\n      return {\n        type: 'nprofile',\n        data: {\n          pubkey: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n    case 'nevent': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nevent')\n      if (tlv[0][0].length !== 32) throw new Error('TLV 0 should be 32 bytes')\n      if (tlv[2] && tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (tlv[3] && tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'nevent',\n        data: {\n          id: bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : undefined,\n          kind: tlv[3]?.[0] ? parseInt(bytesToHex(tlv[3][0]), 16) : undefined,\n        },\n      }\n    }\n\n    case 'naddr': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for naddr')\n      if (!tlv[2]?.[0]) throw new Error('missing TLV 2 for naddr')\n      if (tlv[2][0].length !== 32) throw new Error('TLV 2 should be 32 bytes')\n      if (!tlv[3]?.[0]) throw new Error('missing TLV 3 for naddr')\n      if (tlv[3][0].length !== 4) throw new Error('TLV 3 should be 4 bytes')\n\n      return {\n        type: 'naddr',\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: bytesToHex(tlv[2][0]),\n          kind: parseInt(bytesToHex(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map(d => utf8Decoder.decode(d)) : [],\n        },\n      }\n    }\n\n    case 'nrelay': {\n      let tlv = parseTLV(data)\n      if (!tlv[0]?.[0]) throw new Error('missing TLV 0 for nrelay')\n\n      return {\n        type: 'nrelay',\n        data: utf8Decoder.decode(tlv[0][0]),\n      }\n    }\n\n    case 'nsec':\n    case 'npub':\n    case 'note':\n      return { type: prefix, data: bytesToHex(data) }\n\n    default:\n      throw new Error(`unknown prefix ${prefix}`)\n  }\n}\n\ntype TLV = { [t: number]: Uint8Array[] }\n\nfunction parseTLV(data: Uint8Array): TLV {\n  let result: TLV = {}\n  let rest = data\n  while (rest.length > 0) {\n    let t = rest[0]\n    let l = rest[1]\n    if (!l) throw new Error(`malformed TLV ${t}`)\n    let v = rest.slice(2, 2 + l)\n    rest = rest.slice(2 + l)\n    if (v.length < l) throw new Error(`not enough data to read on TLV ${t}`)\n    result[t] = result[t] || []\n    result[t].push(v)\n  }\n  return result\n}\n\nexport function nsecEncode(hex: string): `nsec1${string}` {\n  return encodeBytes('nsec', hex)\n}\n\nexport function npubEncode(hex: string): `npub1${string}` {\n  return encodeBytes('npub', hex)\n}\n\nexport function noteEncode(hex: string): `note1${string}` {\n  return encodeBytes('note', hex)\n}\n\nfunction encodeBech32<Prefix extends string>(prefix: Prefix, data: Uint8Array): `${Prefix}1${string}` {\n  let words = bech32.toWords(data)\n  return bech32.encode(prefix, words, Bech32MaxSize) as `${Prefix}1${string}`\n}\n\nfunction encodeBytes<Prefix extends string>(prefix: Prefix, hex: string): `${Prefix}1${string}` {\n  let data = hexToBytes(hex)\n  return encodeBech32(prefix, data)\n}\n\nexport function nprofileEncode(profile: ProfilePointer): `nprofile1${string}` {\n  let data = encodeTLV({\n    0: [hexToBytes(profile.pubkey)],\n    1: (profile.relays || []).map(url => utf8Encoder.encode(url)),\n  })\n  return encodeBech32('nprofile', data)\n}\n\nexport function neventEncode(event: EventPointer): `nevent1${string}` {\n  let kindArray\n  if (event.kind != undefined) {\n    kindArray = integerToUint8Array(event.kind)\n  }\n\n  let data = encodeTLV({\n    0: [hexToBytes(event.id)],\n    1: (event.relays || []).map(url => utf8Encoder.encode(url)),\n    2: event.author ? [hexToBytes(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : [],\n  })\n\n  return encodeBech32('nevent', data)\n}\n\nexport function naddrEncode(addr: AddressPointer): `naddr1${string}` {\n  let kind = new ArrayBuffer(4)\n  new DataView(kind).setUint32(0, addr.kind, false)\n\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map(url => utf8Encoder.encode(url)),\n    2: [hexToBytes(addr.pubkey)],\n    3: [new Uint8Array(kind)],\n  })\n  return encodeBech32('naddr', data)\n}\n\nexport function nrelayEncode(url: string): `nrelay1${string}` {\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(url)],\n  })\n  return encodeBech32('nrelay', data)\n}\n\nfunction encodeTLV(tlv: TLV): Uint8Array {\n  let entries: Uint8Array[] = []\n\n  Object.entries(tlv).forEach(([t, vs]) => {\n    vs.forEach(v => {\n      let entry = new Uint8Array(v.length + 2)\n      entry.set([parseInt(t)], 0)\n      entry.set([v.length], 1)\n      entry.set(v, 2)\n      entries.push(entry)\n    })\n  })\n\n  return concatBytes(...entries)\n}\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexport const utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = genBech32('bech32');\nexport const bech32m = genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString;\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n", "import { decode, type AddressPointer, type ProfilePointer, type EventPointer } from './nip19.ts'\n\nimport type { Event } from './event.ts'\n\ntype Reference = {\n  text: string\n  profile?: ProfilePointer\n  event?: EventPointer\n  address?: AddressPointer\n}\n\nconst mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g\n\nexport function parseReferences(evt: Event): Reference[] {\n  let references: Reference[] = []\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      // it's a NIP-27 mention\n      try {\n        let { type, data } = decode(ref[1])\n        switch (type) {\n          case 'npub': {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data as string, relays: [] },\n            })\n            break\n          }\n          case 'nprofile': {\n            references.push({\n              text: ref[0],\n              profile: data as ProfilePointer,\n            })\n            break\n          }\n          case 'note': {\n            references.push({\n              text: ref[0],\n              event: { id: data as string, relays: [] },\n            })\n            break\n          }\n          case 'nevent': {\n            references.push({\n              text: ref[0],\n              event: data as EventPointer,\n            })\n            break\n          }\n          case 'naddr': {\n            references.push({\n              text: ref[0],\n              address: data as AddressPointer,\n            })\n            break\n          }\n        }\n      } catch (err) {\n        /***/\n      }\n    } else if (ref[3]) {\n      // it's a NIP-10 mention\n      let idx = parseInt(ref[3], 10)\n      let tag = evt.tags[idx]\n      if (!tag) continue\n\n      switch (tag[0]) {\n        case 'p': {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] },\n          })\n          break\n        }\n        case 'e': {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] },\n          })\n          break\n        }\n        case 'a': {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(':')\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : [],\n              },\n            })\n          } catch (err) {\n            /***/\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return references\n}\n", "import { randomBytes } from '@noble/hashes/utils'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { base64 } from '@scure/base'\n\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\n// @ts-ignore\nif (typeof crypto !== 'undefined' && !crypto.subtle && crypto.webcrypto) {\n  // @ts-ignore\n  crypto.subtle = crypto.webcrypto.subtle\n}\n\nexport async function encrypt(privkey: string, pubkey: string, text: string): Promise<string> {\n  const key = secp256k1.getSharedSecret(privkey, '02' + pubkey)\n  const normalizedKey = getNormalizedX(key)\n\n  let iv = Uint8Array.from(randomBytes(16))\n  let plaintext = utf8Encoder.encode(text)\n  let cryptoKey = await crypto.subtle.importKey('raw', normalizedKey, { name: 'AES-CBC' }, false, ['encrypt'])\n  let ciphertext = await crypto.subtle.encrypt({ name: 'AES-CBC', iv }, cryptoKey, plaintext)\n  let ctb64 = base64.encode(new Uint8Array(ciphertext))\n  let ivb64 = base64.encode(new Uint8Array(iv.buffer))\n\n  return `${ctb64}?iv=${ivb64}`\n}\n\nexport async function decrypt(privkey: string, pubkey: string, data: string): Promise<string> {\n  let [ctb64, ivb64] = data.split('?iv=')\n  let key = secp256k1.getSharedSecret(privkey, '02' + pubkey)\n  let normalizedKey = getNormalizedX(key)\n\n  let cryptoKey = await crypto.subtle.importKey('raw', normalizedKey, { name: 'AES-CBC' }, false, ['decrypt'])\n  let ciphertext = base64.decode(ctb64)\n  let iv = base64.decode(ivb64)\n\n  let plaintext = await crypto.subtle.decrypt({ name: 'AES-CBC', iv }, cryptoKey, ciphertext)\n\n  let text = utf8Decoder.decode(plaintext)\n  return text\n}\n\nfunction getNormalizedX(key: Uint8Array): Uint8Array {\n  return key.slice(1, 33)\n}\n", "import { ProfilePointer } from './nip19.ts'\n\n/**\n * NIP-05 regex. The localpart is optional, and should be assumed to be `_` otherwise.\n *\n * - 0: full match\n * - 1: name (optional)\n * - 2: domain\n */\nexport const NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function searchDomain(domain: string, query = ''): Promise<{ [name: string]: string }> {\n  try {\n    let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json()\n\n    return res.names\n  } catch (_) {\n    return {}\n  }\n}\n\nexport async function queryProfile(fullname: string): Promise<ProfilePointer | null> {\n  const match = fullname.match(NIP05_REGEX)\n  if (!match) return null\n\n  const [_, name = '_', domain] = match\n\n  try {\n    const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)\n    const { names, relays } = parseNIP05Result(await res.json())\n\n    const pubkey = names[name]\n    return pubkey ? { pubkey, relays: relays?.[pubkey] } : null\n  } catch (_e) {\n    return null\n  }\n}\n\n/** nostr.json result. */\nexport interface NIP05Result {\n  names: {\n    [name: string]: string\n  }\n  relays?: {\n    [pubkey: string]: string[]\n  }\n}\n\n/** Parse the nostr.json and throw if it's not valid. */\nfunction parseNIP05Result(json: any): NIP05Result {\n  const result: NIP05Result = {\n    names: {},\n  }\n\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === 'string' && typeof pubkey === 'string') {\n      result.names[name] = pubkey\n    }\n  }\n\n  if (json.relays) {\n    result.relays = {}\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === 'string' && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay: unknown) => typeof relay === 'string')\n      }\n    }\n  }\n\n  return result\n}\n", "import { bytesToHex } from '@noble/hashes/utils'\nimport { wordlist } from '@scure/bip39/wordlists/english'\nimport { generateMnemonic, mnemonicToSeedSync, validateMnemonic } from '@scure/bip39'\nimport { HDKey } from '@scure/bip32'\n\nexport function privateKeyFromSeedWords(mnemonic: string, passphrase?: string): string {\n  let root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase))\n  let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey\n  if (!privateKey) throw new Error('could not derive private key')\n  return bytesToHex(privateKey)\n}\n\nexport function generateSeedWords(): string {\n  return generateMnemonic(wordlist)\n}\n\nexport function validateWords(words: string): boolean {\n  return validateMnemonic(words, wordlist)\n}\n", null, "import assert from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { Hash, CHash, Input, createView, toBytes, checkOpts, asyncLoop } from './utils.js';\n\n// PBKDF (RFC 2898)\nexport type Pbkdf2Opt = {\n  c: number; // Iterations\n  dkLen?: number; // Desired key length in bytes (Intended output length in octets of the derived key\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n};\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash: CHash, _password: Input, _salt: Input, _opts: Pbkdf2Opt) {\n  assert.hash(hash);\n  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n  const { c, dkLen, asyncTick } = opts;\n  assert.number(c);\n  assert.number(dkLen);\n  assert.number(asyncTick);\n  if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');\n  const password = toBytes(_password);\n  const salt = toBytes(_salt);\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\n\nfunction pbkdf2Output<T extends Hash<T>>(\n  PRF: Hash<T>,\n  PRFSalt: Hash<T>,\n  DK: Uint8Array,\n  prfW: Hash<T>,\n  u: Uint8Array\n) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  u.fill(0);\n  return DK;\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nexport function pbkdf2(hash: CHash, password: Input, salt: Input, opts: Pbkdf2Opt) {\n  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\nexport async function pbkdf2Async(hash: CHash, password: Input, salt: Input, opts: Pbkdf2Opt) {\n  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + \u22EF + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ \u22EF ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await asyncLoop(c - 1, asyncTick, (i) => {\n      // Uc = PRF(Password, Uc\u22121)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n", "const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nexport function split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nexport const toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h: number, l: number) => l;\nconst rotr32L = (h: number, l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n)));\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\n\nexport class SHA512 extends SHA2<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x6a09e667 | 0;\n  Al = 0xf3bcc908 | 0;\n  Bh = 0xbb67ae85 | 0;\n  Bl = 0x84caa73b | 0;\n  Ch = 0x3c6ef372 | 0;\n  Cl = 0xfe94f82b | 0;\n  Dh = 0xa54ff53a | 0;\n  Dl = 0x5f1d36f1 | 0;\n  Eh = 0x510e527f | 0;\n  El = 0xade682d1 | 0;\n  Fh = 0x9b05688c | 0;\n  Fl = 0x2b3e6c1f | 0;\n  Gh = 0x1f83d9ab | 0;\n  Gl = 0xfb41bd6b | 0;\n  Hh = 0x5be0cd19 | 0;\n  Hl = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nclass SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x8c3d37c8 | 0;\n  Al = 0x19544da2 | 0;\n  Bh = 0x73e19966 | 0;\n  Bl = 0x89dcd4d6 | 0;\n  Ch = 0x1dfab7ae | 0;\n  Cl = 0x32ff9c82 | 0;\n  Dh = 0x679dd514 | 0;\n  Dl = 0x582f9fcf | 0;\n  Eh = 0x0f6d2b69 | 0;\n  El = 0x7bd44da8 | 0;\n  Fh = 0x77e36f73 | 0;\n  Fl = 0x04c48942 | 0;\n  Gh = 0x3f9d85a8 | 0;\n  Gl = 0x6a1d36c8 | 0;\n  Hh = 0x1112e6ad | 0;\n  Hl = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nclass SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x22312194 | 0;\n  Al = 0xfc2bf72c | 0;\n  Bh = 0x9f555fa3 | 0;\n  Bl = 0xc84c64c2 | 0;\n  Ch = 0x2393b86b | 0;\n  Cl = 0x6f53b151 | 0;\n  Dh = 0x96387719 | 0;\n  Dl = 0x5940eabd | 0;\n  Eh = 0x96283ee2 | 0;\n  El = 0xa88effe3 | 0;\n  Fh = 0xbe5e1e25 | 0;\n  Fl = 0x53863992 | 0;\n  Gh = 0x2b0199fc | 0;\n  Gl = 0x2c85b8aa | 0;\n  Hh = 0x0eb72ddc | 0;\n  Hl = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nclass SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0xcbbb9d5d | 0;\n  Al = 0xc1059ed8 | 0;\n  Bh = 0x629a292a | 0;\n  Bl = 0x367cd507 | 0;\n  Ch = 0x9159015a | 0;\n  Cl = 0x3070dd17 | 0;\n  Dh = 0x152fecd8 | 0;\n  Dl = 0xf70e5939 | 0;\n  Eh = 0x67332667 | 0;\n  El = 0xffc00b31 | 0;\n  Fh = 0x8eb44a87 | 0;\n  Fl = 0x68581511 | 0;\n  Gh = 0xdb0c2e0d | 0;\n  Gl = 0x64f98fa7 | 0;\n  Hh = 0x47b5481d | 0;\n  Hl = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\nexport const sha512 = wrapConstructor(() => new SHA512());\nexport const sha512_224 = wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = wrapConstructor(() => new SHA512_256());\nexport const sha384 = wrapConstructor(() => new SHA384());\n", null, "import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++) for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));\n\nconst shifts = [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\n\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\n\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word: number, shift: number) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  else if (group === 1) return (x & y) | (~x & z);\n  else if (group === 2) return (x | ~y) ^ z;\n  else if (group === 3) return (x & z) | (y & ~z);\n  else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nexport class RIPEMD160 extends SHA2<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number) {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean() {\n    BUF.fill(0);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = wrapConstructor(() => new RIPEMD160());\n", "/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { bytes as assertBytes } from '@noble/hashes/_assert';\nimport { bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { base58check as base58checker } from '@scure/base';\n\nconst Point = secp.ProjectivePoint;\nconst base58check = base58checker(sha256);\n\nfunction bytesToNumber(bytes: Uint8Array): bigint {\n  return BigInt(`0x${bytesToHex(bytes)}`);\n}\n\nfunction numberToBytes(num: bigint): Uint8Array {\n  return hexToBytes(num.toString(16).padStart(64, '0'));\n}\n\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS: Versions = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET: number = 0x80000000;\n\nexport interface Versions {\n  private: number;\n  public: number;\n}\n\nconst hash160 = (data: Uint8Array) => ripemd160(sha256(data));\nconst fromU32 = (data: Uint8Array) => createView(data).getUint32(0, false);\nconst toU32 = (n: number) => {\n  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n    throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n  }\n  const buf = new Uint8Array(4);\n  createView(buf).setUint32(0, n, false);\n  return buf;\n};\n\ninterface HDKeyOpt {\n  versions: Versions;\n  depth?: number;\n  index?: number;\n  parentFingerprint?: number;\n  chainCode: Uint8Array;\n  publicKey?: Uint8Array;\n  privateKey?: Uint8Array | bigint;\n}\n\nexport class HDKey {\n  get fingerprint(): number {\n    if (!this.pubHash) {\n      throw new Error('No publicKey set!');\n    }\n    return fromU32(this.pubHash);\n  }\n  get identifier(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get pubKeyHash(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get privateKey(): Uint8Array | null {\n    return this.privKeyBytes || null;\n  }\n  get publicKey(): Uint8Array | null {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey(): string {\n    const priv = this.privateKey;\n    if (!priv) {\n      throw new Error('No private key');\n    }\n    return base58check.encode(\n      this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv))\n    );\n  }\n  get publicExtendedKey(): string {\n    if (!this.pubKey) {\n      throw new Error('No public key');\n    }\n    return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n\n  public static fromMasterSeed(seed: Uint8Array, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    assertBytes(seed);\n    if (8 * seed.length < 128 || 8 * seed.length > 512) {\n      throw new Error(\n        `HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`\n      );\n    }\n    const I = hmac(sha512, MASTER_SECRET, seed);\n    return new HDKey({\n      versions,\n      chainCode: I.slice(32),\n      privateKey: I.slice(0, 32),\n    });\n  }\n\n  public static fromExtendedKey(base58key: string, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    const keyBuffer: Uint8Array = base58check.decode(base58key);\n    const keyView = createView(keyBuffer);\n    const version = keyView.getUint32(0, false);\n    const opt = {\n      versions,\n      depth: keyBuffer[4],\n      parentFingerprint: keyView.getUint32(5, false),\n      index: keyView.getUint32(9, false),\n      chainCode: keyBuffer.slice(13, 45),\n    };\n    const key = keyBuffer.slice(45);\n    const isPriv = key[0] === 0;\n    if (version !== versions[isPriv ? 'private' : 'public']) {\n      throw new Error('Version mismatch');\n    }\n    if (isPriv) {\n      return new HDKey({ ...opt, privateKey: key.slice(1) });\n    } else {\n      return new HDKey({ ...opt, publicKey: key });\n    }\n  }\n\n  public static fromJSON(json: { xpriv: string }): HDKey {\n    return HDKey.fromExtendedKey(json.xpriv);\n  }\n  public readonly versions: Versions;\n  public readonly depth: number = 0;\n  public readonly index: number = 0;\n  public readonly chainCode: Uint8Array | null = null;\n  public readonly parentFingerprint: number = 0;\n  private privKey?: bigint;\n  private privKeyBytes?: Uint8Array;\n  private pubKey?: Uint8Array;\n  private pubHash: Uint8Array | undefined;\n\n  constructor(opt: HDKeyOpt) {\n    if (!opt || typeof opt !== 'object') {\n      throw new Error('HDKey.constructor must not be called directly');\n    }\n    this.versions = opt.versions || BITCOIN_VERSIONS;\n    this.depth = opt.depth || 0;\n    this.chainCode = opt.chainCode;\n    this.index = opt.index || 0;\n    this.parentFingerprint = opt.parentFingerprint || 0;\n    if (!this.depth) {\n      if (this.parentFingerprint || this.index) {\n        throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n      }\n    }\n    if (opt.publicKey && opt.privateKey) {\n      throw new Error('HDKey: publicKey and privateKey at same time.');\n    }\n    if (opt.privateKey) {\n      if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n        throw new Error('Invalid private key');\n      }\n      this.privKey =\n        typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n      this.privKeyBytes = numberToBytes(this.privKey);\n      this.pubKey = secp.getPublicKey(opt.privateKey, true);\n    } else if (opt.publicKey) {\n      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n    } else {\n      throw new Error('HDKey: no public or private key provided');\n    }\n    this.pubHash = hash160(this.pubKey);\n  }\n\n  public derive(path: string): HDKey {\n    if (!/^[mM]'?/.test(path)) {\n      throw new Error('Path must start with \"m\" or \"M\"');\n    }\n    if (/^[mM]'?$/.test(path)) {\n      return this;\n    }\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    // tslint:disable-next-line\n    let child: HDKey = this;\n    for (const c of parts) {\n      const m = /^(\\d+)('?)$/.exec(c);\n      if (!m || m.length !== 3) {\n        throw new Error(`Invalid child index: ${c}`);\n      }\n      let idx = +m[1];\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n        throw new Error('Invalid index');\n      }\n      // hardened key\n      if (m[2] === \"'\") {\n        idx += HARDENED_OFFSET;\n      }\n      child = child.deriveChild(idx);\n    }\n    return child;\n  }\n\n  public deriveChild(index: number): HDKey {\n    if (!this.pubKey || !this.chainCode) {\n      throw new Error('No publicKey or chainCode set');\n    }\n    let data = toU32(index);\n    if (index >= HARDENED_OFFSET) {\n      // Hardened\n      const priv = this.privateKey;\n      if (!priv) {\n        throw new Error('Could not derive hardened child key');\n      }\n      // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n      data = concatBytes(new Uint8Array([0]), priv, data);\n    } else {\n      // Normal child: serP(point(kpar)) || ser32(index)\n      data = concatBytes(this.pubKey, data);\n    }\n    const I = hmac(sha512, this.chainCode, data);\n    const childTweak = bytesToNumber(I.slice(0, 32));\n    const chainCode = I.slice(32);\n    if (!secp.utils.isValidPrivateKey(childTweak)) {\n      throw new Error('Tweak bigger than curve order');\n    }\n    const opt: HDKeyOpt = {\n      versions: this.versions,\n      chainCode,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index,\n    };\n    try {\n      // Private parent key -> private child key\n      if (this.privateKey) {\n        const added = mod(this.privKey! + childTweak, secp.CURVE.n);\n        if (!secp.utils.isValidPrivateKey(added)) {\n          throw new Error('The tweak was out of range or the resulted private key is invalid');\n        }\n        opt.privateKey = added;\n      } else {\n        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n        // Cryptographically impossible: hmac-sha512 preimage would need to be found\n        if (added.equals(Point.ZERO)) {\n          throw new Error('The tweak was equal to negative P, which made the result key invalid');\n        }\n        opt.publicKey = added.toRawBytes(true);\n      }\n      return new HDKey(opt);\n    } catch (err) {\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  public sign(hash: Uint8Array): Uint8Array {\n    if (!this.privateKey) {\n      throw new Error('No privateKey set!');\n    }\n    assertBytes(hash, 32);\n    return secp.sign(hash, this.privKey!).toCompactRawBytes();\n  }\n\n  public verify(hash: Uint8Array, signature: Uint8Array): boolean {\n    assertBytes(hash, 32);\n    assertBytes(signature, 64);\n    if (!this.publicKey) {\n      throw new Error('No publicKey set!');\n    }\n    let sig;\n    try {\n      sig = secp.Signature.fromCompact(signature);\n    } catch (error) {\n      return false;\n    }\n    return secp.verify(sig, hash, this.publicKey);\n  }\n\n  public wipePrivateData(): this {\n    this.privKey = undefined;\n    if (this.privKeyBytes) {\n      this.privKeyBytes.fill(0);\n      this.privKeyBytes = undefined;\n    }\n    return this;\n  }\n  public toJSON(): { xpriv: string; xpub: string } {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey,\n    };\n  }\n\n  private serialize(version: number, key: Uint8Array) {\n    if (!this.chainCode) {\n      throw new Error('No chainCode set');\n    }\n    assertBytes(key, 33);\n    // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    return concatBytes(\n      toU32(version),\n      new Uint8Array([this.depth]),\n      toU32(this.parentFingerprint),\n      toU32(this.index),\n      this.chainCode,\n      key\n    );\n  }\n}\n", "import type { Event } from './event.ts'\nimport type { EventPointer, ProfilePointer } from './nip19.ts'\n\nexport type NIP10Result = {\n  /**\n   * Pointer to the root of the thread.\n   */\n  root: EventPointer | undefined\n\n  /**\n   * Pointer to a \"parent\" event that parsed event replies to (responded to).\n   */\n  reply: EventPointer | undefined\n\n  /**\n   * Pointers to events which may or may not be in the reply chain.\n   */\n  mentions: EventPointer[]\n\n  /**\n   * List of pubkeys that are involved in the thread in no particular order.\n   */\n  profiles: ProfilePointer[]\n}\n\nexport function parse(event: Pick<Event, 'tags'>): NIP10Result {\n  const result: NIP10Result = {\n    reply: undefined,\n    root: undefined,\n    mentions: [],\n    profiles: [],\n  }\n\n  const eTags: string[][] = []\n\n  for (const tag of event.tags) {\n    if (tag[0] === 'e' && tag[1]) {\n      eTags.push(tag)\n    }\n\n    if (tag[0] === 'p' && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : [],\n      })\n    }\n  }\n\n  for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {\n    const eTag = eTags[eTagIndex]\n\n    const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag as [string, string, undefined | string, undefined | string]\n\n    const eventPointer: EventPointer = {\n      id: eTagEventId,\n      relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n    }\n\n    const isFirstETag = eTagIndex === 0\n    const isLastETag = eTagIndex === eTags.length - 1\n\n    if (eTagMarker === 'root') {\n      result.root = eventPointer\n      continue\n    }\n\n    if (eTagMarker === 'reply') {\n      result.reply = eventPointer\n      continue\n    }\n\n    if (eTagMarker === 'mention') {\n      result.mentions.push(eventPointer)\n      continue\n    }\n\n    if (isFirstETag) {\n      result.root = eventPointer\n      continue\n    }\n\n    if (isLastETag) {\n      result.reply = eventPointer\n      continue\n    }\n\n    result.mentions.push(eventPointer)\n  }\n\n  return result\n}\n", "import { type UnsignedEvent, type Event, getEventHash } from './event.ts'\n\n/** Get POW difficulty from a Nostr hex ID. */\nexport function getPow(hex: string): number {\n  let count = 0\n\n  for (let i = 0; i < hex.length; i++) {\n    const nibble = parseInt(hex[i], 16)\n    if (nibble === 0) {\n      count += 4\n    } else {\n      count += Math.clz32(nibble) - 28\n      break\n    }\n  }\n\n  return count\n}\n\n/**\n * Mine an event with the desired POW. This function mutates the event.\n * Note that this operation is synchronous and should be run in a worker context to avoid blocking the main thread.\n *\n * Adapted from Snort: https://git.v0l.io/Kieran/snort/src/commit/4df6c19248184218c4c03728d61e94dae5f2d90c/packages/system/src/pow-util.ts#L14-L36\n */\nexport function minePow<K extends number>(unsigned: UnsignedEvent<K>, difficulty: number): Omit<Event<K>, 'sig'> {\n  let count = 0\n\n  const event = unsigned as Omit<Event<K>, 'sig'>\n  const tag = ['nonce', count.toString(), difficulty.toString()]\n\n  event.tags.push(tag)\n\n  while (true) {\n    const now = Math.floor(new Date().getTime() / 1000)\n\n    if (now !== event.created_at) {\n      count = 0\n      event.created_at = now\n    }\n\n    tag[1] = (++count).toString()\n\n    event.id = getEventHash(event)\n\n    if (getPow(event.id) >= difficulty) {\n      break\n    }\n  }\n\n  return event\n}\n", "import { Event, finishEvent, Kind, verifySignature } from './event.ts'\nimport { EventPointer } from './nip19.ts'\n\nexport type RepostEventTemplate = {\n  /**\n   * Pass only non-nip18 tags if you have to.\n   * Nip18 tags ('e' and 'p' tags pointing to the reposted event) will be added automatically.\n   */\n  tags?: string[][]\n\n  /**\n   * Pass an empty string to NOT include the stringified JSON of the reposted event.\n   * Any other content will be ignored and replaced with the stringified JSON of the reposted event.\n   * @default Stringified JSON of the reposted event\n   */\n  content?: ''\n\n  created_at: number\n}\n\nexport function finishRepostEvent(\n  t: RepostEventTemplate,\n  reposted: Event<number>,\n  relayUrl: string,\n  privateKey: string,\n): Event<Kind.Repost> {\n  return finishEvent(\n    {\n      kind: Kind.Repost,\n      tags: [...(t.tags ?? []), ['e', reposted.id, relayUrl], ['p', reposted.pubkey]],\n      content: t.content === '' ? '' : JSON.stringify(reposted),\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport function getRepostedEventPointer(event: Event<number>): undefined | EventPointer {\n  if (event.kind !== Kind.Repost) {\n    return undefined\n  }\n\n  let lastETag: undefined | string[]\n  let lastPTag: undefined | string[]\n\n  for (let i = event.tags.length - 1; i >= 0 && (lastETag === undefined || lastPTag === undefined); i--) {\n    const tag = event.tags[i]\n    if (tag.length >= 2) {\n      if (tag[0] === 'e' && lastETag === undefined) {\n        lastETag = tag\n      } else if (tag[0] === 'p' && lastPTag === undefined) {\n        lastPTag = tag\n      }\n    }\n  }\n\n  if (lastETag === undefined) {\n    return undefined\n  }\n\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x): x is string => typeof x === 'string'),\n    author: lastPTag?.[1],\n  }\n}\n\nexport type GetRepostedEventOptions = {\n  skipVerification?: boolean\n}\n\nexport function getRepostedEvent(\n  event: Event<number>,\n  { skipVerification }: GetRepostedEventOptions = {},\n): undefined | Event<number> {\n  const pointer = getRepostedEventPointer(event)\n\n  if (pointer === undefined || event.content === '') {\n    return undefined\n  }\n\n  let repostedEvent: undefined | Event<number>\n\n  try {\n    repostedEvent = JSON.parse(event.content) as Event<number>\n  } catch (error) {\n    return undefined\n  }\n\n  if (repostedEvent.id !== pointer.id) {\n    return undefined\n  }\n\n  if (!skipVerification && !verifySignature(repostedEvent)) {\n    return undefined\n  }\n\n  return repostedEvent\n}\n", "import { BECH32_REGEX, decode, type DecodeResult } from './nip19.ts'\n\n/** Nostr URI regex, eg `nostr:npub1...` */\nexport const NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`)\n\n/** Test whether the value is a Nostr URI. */\nexport function test(value: unknown): value is `nostr:${string}` {\n  return typeof value === 'string' && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value)\n}\n\n/** Parsed Nostr URI data. */\nexport interface NostrURI {\n  /** Full URI including the `nostr:` protocol. */\n  uri: `nostr:${string}`\n  /** The bech32-encoded data (eg `npub1...`). */\n  value: string\n  /** Decoded bech32 string, according to NIP-19. */\n  decoded: DecodeResult\n}\n\n/** Parse and decode a Nostr URI. */\nexport function parse(uri: string): NostrURI {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`))\n  if (!match) throw new Error(`Invalid Nostr URI: ${uri}`)\n  return {\n    uri: match[0] as `nostr:${string}`,\n    value: match[1],\n    decoded: decode(match[1]),\n  }\n}\n", "import { Event, finishEvent, Kind } from './event.ts'\n\nimport type { EventPointer } from './nip19.ts'\n\nexport type ReactionEventTemplate = {\n  /**\n   * Pass only non-nip25 tags if you have to. Nip25 tags ('e' and 'p' tags from reacted event) will be added automatically.\n   */\n  tags?: string[][]\n\n  /**\n   * @default '+'\n   */\n  content?: string\n\n  created_at: number\n}\n\nexport function finishReactionEvent(\n  t: ReactionEventTemplate,\n  reacted: Event<number>,\n  privateKey: string,\n): Event<Kind.Reaction> {\n  const inheritedTags = reacted.tags.filter(tag => tag.length >= 2 && (tag[0] === 'e' || tag[0] === 'p'))\n\n  return finishEvent(\n    {\n      ...t,\n      kind: Kind.Reaction,\n      tags: [...(t.tags ?? []), ...inheritedTags, ['e', reacted.id], ['p', reacted.pubkey]],\n      content: t.content ?? '+',\n    },\n    privateKey,\n  )\n}\n\nexport function getReactedEventPointer(event: Event<number>): undefined | EventPointer {\n  if (event.kind !== Kind.Reaction) {\n    return undefined\n  }\n\n  let lastETag: undefined | string[]\n  let lastPTag: undefined | string[]\n\n  for (let i = event.tags.length - 1; i >= 0 && (lastETag === undefined || lastPTag === undefined); i--) {\n    const tag = event.tags[i]\n    if (tag.length >= 2) {\n      if (tag[0] === 'e' && lastETag === undefined) {\n        lastETag = tag\n      } else if (tag[0] === 'p' && lastPTag === undefined) {\n        lastPTag = tag\n      }\n    }\n  }\n\n  if (lastETag === undefined || lastPTag === undefined) {\n    return undefined\n  }\n\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter(x => x !== undefined),\n    author: lastPTag[1],\n  }\n}\n", "import { schnorr } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@noble/hashes/utils'\nimport { sha256 } from '@noble/hashes/sha256'\n\nimport { utf8Encoder } from './utils.ts'\nimport { getPublicKey } from './keys.ts'\n\nimport type { Event } from './event.ts'\n\nexport type Parameters = {\n  pubkey: string // the key to whom the delegation will be given\n  kind?: number\n  until?: number // delegation will only be valid until this date\n  since?: number // delegation will be valid from this date on\n}\n\nexport type Delegation = {\n  from: string // the pubkey who signed the delegation\n  to: string // the pubkey that is allowed to use the delegation\n  cond: string // the string of conditions as they should be included in the event tag\n  sig: string\n}\n\nexport function createDelegation(privateKey: string, parameters: Parameters): Delegation {\n  let conditions = []\n  if ((parameters.kind || -1) >= 0) conditions.push(`kind=${parameters.kind}`)\n  if (parameters.until) conditions.push(`created_at<${parameters.until}`)\n  if (parameters.since) conditions.push(`created_at>${parameters.since}`)\n  let cond = conditions.join('&')\n\n  if (cond === '') throw new Error('refusing to create a delegation without any conditions')\n\n  let sighash = sha256(utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`))\n\n  let sig = bytesToHex(schnorr.sign(sighash, privateKey))\n\n  return {\n    from: getPublicKey(privateKey),\n    to: parameters.pubkey,\n    cond,\n    sig,\n  }\n}\n\nexport function getDelegator(event: Event<number>): string | null {\n  // find delegation tag\n  let tag = event.tags.find(tag => tag[0] === 'delegation' && tag.length >= 4)\n  if (!tag) return null\n\n  let pubkey = tag[1]\n  let cond = tag[2]\n  let sig = tag[3]\n\n  // check conditions\n  let conditions = cond.split('&')\n  for (let i = 0; i < conditions.length; i++) {\n    let [key, operator, value] = conditions[i].split(/\\b/)\n\n    // the supported conditions are just 'kind' and 'created_at' for now\n    if (key === 'kind' && operator === '=' && event.kind === parseInt(value)) continue\n    else if (key === 'created_at' && operator === '<' && event.created_at < parseInt(value)) continue\n    else if (key === 'created_at' && operator === '>' && event.created_at > parseInt(value)) continue\n    else return null // invalid condition\n  }\n\n  // check signature\n  let sighash = sha256(utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`))\n  if (!schnorr.verify(sig, sighash, pubkey)) return null\n\n  return pubkey\n}\n", "import { decode } from './nip19.ts'\nimport { NOSTR_URI_REGEX, type NostrURI } from './nip21.ts'\n\n/** Regex to find NIP-21 URIs inside event content. */\nexport const regex = () => new RegExp(`\\\\b${NOSTR_URI_REGEX.source}\\\\b`, 'g')\n\n/** Match result for a Nostr URI in event content. */\nexport interface NostrURIMatch extends NostrURI {\n  /** Index where the URI begins in the event content. */\n  start: number\n  /** Index where the URI ends in the event content. */\n  end: number\n}\n\n/** Find and decode all NIP-21 URIs. */\nexport function* matchAll(content: string): Iterable<NostrURIMatch> {\n  const matches = content.matchAll(regex())\n\n  for (const match of matches) {\n    try {\n      const [uri, value] = match\n\n      yield {\n        uri: uri as `nostr:${string}`,\n        value,\n        decoded: decode(value),\n        start: match.index!,\n        end: match.index! + uri.length,\n      }\n    } catch (_e) {\n      // do nothing\n    }\n  }\n}\n\n/**\n * Replace all occurrences of Nostr URIs in the text.\n *\n * WARNING: using this on an HTML string is potentially unsafe!\n *\n * @example\n * ```ts\n * nip27.replaceAll(event.content, ({ decoded, value }) => {\n *   switch(decoded.type) {\n *     case 'npub':\n *       return renderMention(decoded)\n *     case 'note':\n *       return renderNote(decoded)\n *     default:\n *       return value\n *   }\n * })\n * ```\n */\nexport function replaceAll(content: string, replacer: (match: NostrURI) => string): string {\n  return content.replaceAll(regex(), (uri, value: string) => {\n    return replacer({\n      uri: uri as `nostr:${string}`,\n      value,\n      decoded: decode(value),\n    })\n  })\n}\n", "import { Event, finishEvent, Kind } from './event.ts'\n\nexport interface ChannelMetadata {\n  name: string\n  about: string\n  picture: string\n}\n\nexport interface ChannelCreateEventTemplate {\n  /* JSON string containing ChannelMetadata as defined for Kind 40 and 41 in nip-28. */\n  content: string | ChannelMetadata\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelMetadataEventTemplate {\n  channel_create_event_id: string\n  /* JSON string containing ChannelMetadata as defined for Kind 40 and 41 in nip-28. */\n  content: string | ChannelMetadata\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelMessageEventTemplate {\n  channel_create_event_id: string\n  reply_to_channel_message_event_id?: string\n  relay_url: string\n  content: string\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelHideMessageEventTemplate {\n  channel_message_event_id: string\n  content: string | { reason: string }\n  created_at: number\n  tags?: string[][]\n}\n\nexport interface ChannelMuteUserEventTemplate {\n  content: string | { reason: string }\n  created_at: number\n  pubkey_to_mute: string\n  tags?: string[][]\n}\n\nexport const channelCreateEvent = (\n  t: ChannelCreateEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelCreation> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelCreation,\n      tags: [...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport const channelMetadataEvent = (\n  t: ChannelMetadataEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelMetadata> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelMetadata,\n      tags: [['e', t.channel_create_event_id], ...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport const channelMessageEvent = (t: ChannelMessageEventTemplate, privateKey: string): Event<Kind.ChannelMessage> => {\n  const tags = [['e', t.channel_create_event_id, t.relay_url, 'root']]\n\n  if (t.reply_to_channel_message_event_id) {\n    tags.push(['e', t.reply_to_channel_message_event_id, t.relay_url, 'reply'])\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelMessage,\n      tags: [...tags, ...(t.tags ?? [])],\n      content: t.content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\n/* \"e\" tag should be the kind 42 event to hide */\nexport const channelHideMessageEvent = (\n  t: ChannelHideMessageEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelHideMessage> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelHideMessage,\n      tags: [['e', t.channel_message_event_id], ...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n\nexport const channelMuteUserEvent = (\n  t: ChannelMuteUserEventTemplate,\n  privateKey: string,\n): Event<Kind.ChannelMuteUser> | undefined => {\n  let content: string\n  if (typeof t.content === 'object') {\n    content = JSON.stringify(t.content)\n  } else if (typeof t.content === 'string') {\n    content = t.content\n  } else {\n    return undefined\n  }\n\n  return finishEvent(\n    {\n      kind: Kind.ChannelMuteUser,\n      tags: [['p', t.pubkey_to_mute], ...(t.tags ?? [])],\n      content: content,\n      created_at: t.created_at,\n    },\n    privateKey,\n  )\n}\n", "var _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function validateGithub(pubkey: string, username: string, proof: string): Promise<boolean> {\n  try {\n    let res = await (await _fetch(`https://gist.github.com/${username}/${proof}/raw`)).text()\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`\n  } catch (_) {\n    return false\n  }\n}\n", "import { Kind, type EventTemplate, type Event } from './event.ts'\nimport { Relay } from './relay.ts'\n\n/**\n * Authenticate via NIP-42 flow.\n *\n * @example\n * const sign = window.nostr.signEvent\n * relay.on('auth', challenge =>\n *   authenticate({ relay, sign, challenge })\n * )\n */\nexport const authenticate = async ({\n  challenge,\n  relay,\n  sign,\n}: {\n  challenge: string\n  relay: Relay\n  sign: <K extends number = number>(e: EventTemplate<K>) => Promise<Event<K>> | Event<K>\n}): Promise<void> => {\n  const e: EventTemplate = {\n    kind: Kind.ClientAuth,\n    created_at: Math.floor(Date.now() / 1000),\n    tags: [\n      ['relay', relay.url],\n      ['challenge', challenge],\n    ],\n    content: '',\n  }\n  return relay.auth(await sign(e))\n}\n", "import { chacha20 } from '@noble/ciphers/chacha'\nimport { ensureBytes, equalBytes } from '@noble/ciphers/utils'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { hkdf } from '@noble/hashes/hkdf'\nimport { hmac } from '@noble/hashes/hmac'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { concatBytes, randomBytes } from '@noble/hashes/utils'\nimport { base64 } from '@scure/base'\nimport { utf8Decoder, utf8Encoder } from './utils.ts'\n\nexport const utils = {\n  v2: {\n    maxPlaintextSize: 65536 - 128, // 64kb - 128\n    minCiphertextSize: 100, // should be 128 if min padded to 32b: base64(1+32+32+32)\n    maxCiphertextSize: 102400, // 100kb\n\n    getConversationKey(privkeyA: string, pubkeyB: string): Uint8Array {\n      const key = secp256k1.getSharedSecret(privkeyA, '02' + pubkeyB)\n      return key.subarray(1, 33)\n    },\n\n    getMessageKeys(conversationKey: Uint8Array, salt: Uint8Array) {\n      const keys = hkdf(sha256, conversationKey, salt, 'nip44-v2', 76)\n      return {\n        encryption: keys.subarray(0, 32),\n        nonce: keys.subarray(32, 44),\n        auth: keys.subarray(44, 76),\n      }\n    },\n\n    calcPadding(len: number): number {\n      if (!Number.isSafeInteger(len) || len < 0) throw new Error('expected positive integer')\n      if (len <= 32) return 32\n      const nextpower = 1 << (Math.floor(Math.log2(len - 1)) + 1)\n      const chunk = nextpower <= 256 ? 32 : nextpower / 8\n      return chunk * (Math.floor((len - 1) / chunk) + 1)\n    },\n\n    pad(unpadded: string): Uint8Array {\n      const unpaddedB = utf8Encoder.encode(unpadded)\n      const len = unpaddedB.length\n      if (len < 1 || len >= utils.v2.maxPlaintextSize) throw new Error('invalid plaintext length: must be between 1b and 64KB')\n      const paddedLen = utils.v2.calcPadding(len)\n      const zeros = new Uint8Array(paddedLen - len)\n      const lenBuf = new Uint8Array(2)\n      new DataView(lenBuf.buffer).setUint16(0, len)\n      return concatBytes(lenBuf, unpaddedB, zeros)\n    },\n\n    unpad(padded: Uint8Array): string {\n      const unpaddedLen = new DataView(padded.buffer).getUint16(0)\n      const unpadded = padded.subarray(2, 2 + unpaddedLen)\n      if (\n        unpaddedLen === 0 ||\n        unpadded.length !== unpaddedLen ||\n        padded.length !== 2 + utils.v2.calcPadding(unpaddedLen)\n      )\n        throw new Error('invalid padding')\n      return utf8Decoder.decode(unpadded)\n    },\n  },\n}\n\nexport function encrypt(\n  key: Uint8Array,\n  plaintext: string,\n  options: { salt?: Uint8Array; version?: number } = {},\n): string {\n  const version = options.version ?? 2\n  if (version !== 2) throw new Error('unknown encryption version ' + version)\n  const salt = options.salt ?? randomBytes(32)\n  ensureBytes(salt, 32)\n  const keys = utils.v2.getMessageKeys(key, salt)\n  const padded = utils.v2.pad(plaintext)\n  const ciphertext = chacha20(keys.encryption, keys.nonce, padded)\n  const mac = hmac(sha256, keys.auth, ciphertext)\n  return base64.encode(concatBytes(new Uint8Array([version]), salt, ciphertext, mac))\n}\n\nexport function decrypt(key: Uint8Array, ciphertext: string): string {\n  const u = utils.v2\n  ensureBytes(key, 32)\n\n  const clen = ciphertext.length\n  if (clen < u.minCiphertextSize || clen >= u.maxCiphertextSize) throw new Error('invalid ciphertext length: ' + clen)\n\n  if (ciphertext[0] === '#') throw new Error('unknown encryption version')\n  let data: Uint8Array\n  try {\n    data = base64.decode(ciphertext)\n  } catch (error) {\n    throw new Error('invalid base64: ' + (error as any).message)\n  }\n  const vers = data.subarray(0, 1)[0]\n  if (vers !== 2) throw new Error('unknown encryption version ' + vers)\n\n  const salt = data.subarray(1, 33)\n  const ciphertext_ = data.subarray(33, -32)\n  const mac = data.subarray(-32)\n\n  const keys = u.getMessageKeys(key, salt)\n  const calculatedMac = hmac(sha256, keys.auth, ciphertext_)\n  if (!equalBytes(calculatedMac, mac)) throw new Error('invalid MAC')\n\n  const padded = chacha20(keys.encryption, keys.nonce, ciphertext_)\n  return u.unpad(padded)\n}\n", "/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u16 = (arr: TypedArray) =>\n  new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new Error('options must be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport function ensureBytes(b: any, len?: number) {\n  if (!(b instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  if (typeof len === 'number')\n    if (b.length !== len) throw new Error(`Uint8Array length ${len} expected`);\n}\n\n// Constant-time equality\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  // Should not happen\n  if (a.length !== b.length) throw new Error('equalBytes: Different size of Uint8Arrays');\n  let isSame = true;\n  for (let i = 0; i < a.length; i++) isSame &&= a[i] === b[i]; // Lets hope JIT won't optimize away.\n  return isSame;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\nexport type Cipher = {\n  tagLength?: number;\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\nexport type AsyncCipher = {\n  tagLength?: number;\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n// Polyfill for Safari 14\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n", "function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('hash must be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n", "import { toBytes, Input, ensureBytes, Hash } from './utils.js';\nimport assert from './_assert.js';\n\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a: Uint8Array, i: number) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 implements Hash<Poly1305> {\n  readonly blockLen = 16;\n  readonly outputLen = 16;\n  private buffer = new Uint8Array(16);\n  private r = new Uint16Array(10);\n  private h = new Uint16Array(10);\n  private pad = new Uint16Array(8);\n  private pos = 0;\n  protected finished = false;\n\n  constructor(key: Input) {\n    key = toBytes(key);\n    ensureBytes(key, 32);\n    const t0 = u8to16(key, 0);\n    const t1 = u8to16(key, 2);\n    const t2 = u8to16(key, 4);\n    const t3 = u8to16(key, 6);\n    const t4 = u8to16(key, 8);\n    const t5 = u8to16(key, 10);\n    const t6 = u8to16(key, 12);\n    const t7 = u8to16(key, 14);\n\n    // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n    this.r[5] = (t4 >>> 1) & 0x1ffe;\n    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n    this.r[9] = (t7 >>> 5) & 0x007f;\n    for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);\n  }\n\n  private process(data: Uint8Array, offset: number, isLast = false) {\n    const hibit = isLast ? 0 : 1 << 11;\n    const { h, r } = this;\n    const r0 = r[0];\n    const r1 = r[1];\n    const r2 = r[2];\n    const r3 = r[3];\n    const r4 = r[4];\n    const r5 = r[5];\n    const r6 = r[6];\n    const r7 = r[7];\n    const r8 = r[8];\n    const r9 = r[9];\n\n    const t0 = u8to16(data, offset + 0);\n    const t1 = u8to16(data, offset + 2);\n    const t2 = u8to16(data, offset + 4);\n    const t3 = u8to16(data, offset + 6);\n    const t4 = u8to16(data, offset + 8);\n    const t5 = u8to16(data, offset + 10);\n    const t6 = u8to16(data, offset + 12);\n    const t7 = u8to16(data, offset + 14);\n\n    let h0 = h[0] + (t0 & 0x1fff);\n    let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n    let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n    let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n    let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n    let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n    let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n    let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n    let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n    let h9 = h[9] + ((t7 >>> 5) | hibit);\n\n    let c = 0;\n\n    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n    c = d0 >>> 13;\n    d0 &= 0x1fff;\n    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n    c += d0 >>> 13;\n    d0 &= 0x1fff;\n\n    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n    c = d1 >>> 13;\n    d1 &= 0x1fff;\n    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n    c += d1 >>> 13;\n    d1 &= 0x1fff;\n\n    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n    c = d2 >>> 13;\n    d2 &= 0x1fff;\n    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n    c += d2 >>> 13;\n    d2 &= 0x1fff;\n\n    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n    c = d3 >>> 13;\n    d3 &= 0x1fff;\n    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n    c += d3 >>> 13;\n    d3 &= 0x1fff;\n\n    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n    c = d4 >>> 13;\n    d4 &= 0x1fff;\n    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n    c += d4 >>> 13;\n    d4 &= 0x1fff;\n\n    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n    c = d5 >>> 13;\n    d5 &= 0x1fff;\n    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n    c += d5 >>> 13;\n    d5 &= 0x1fff;\n\n    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n    c = d6 >>> 13;\n    d6 &= 0x1fff;\n    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n    c += d6 >>> 13;\n    d6 &= 0x1fff;\n\n    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n    c = d7 >>> 13;\n    d7 &= 0x1fff;\n    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n    c += d7 >>> 13;\n    d7 &= 0x1fff;\n\n    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n    c = d8 >>> 13;\n    d8 &= 0x1fff;\n    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n    c += d8 >>> 13;\n    d8 &= 0x1fff;\n\n    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n    c = d9 >>> 13;\n    d9 &= 0x1fff;\n    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n    c += d9 >>> 13;\n    d9 &= 0x1fff;\n\n    c = ((c << 2) + c) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = c >>> 13;\n    d1 += c;\n\n    h[0] = d0;\n    h[1] = d1;\n    h[2] = d2;\n    h[3] = d3;\n    h[4] = d4;\n    h[5] = d5;\n    h[6] = d6;\n    h[7] = d7;\n    h[8] = d8;\n    h[9] = d9;\n  }\n\n  private finalize() {\n    const { h, pad } = this;\n    const g = new Uint16Array(10);\n    let c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    for (let i = 2; i < 10; i++) {\n      h[i] += c;\n      c = h[i] >>> 13;\n      h[i] &= 0x1fff;\n    }\n    h[0] += c * 5;\n    c = h[0] >>> 13;\n    h[0] &= 0x1fff;\n    h[1] += c;\n    c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    h[2] += c;\n\n    g[0] = h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (let i = 1; i < 10; i++) {\n      g[i] = h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n\n    let mask = (c ^ 1) - 1;\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];\n    h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n    h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n    h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n    h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n    h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n    h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n    h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n    h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\n    let f = h[0] + pad[0];\n    h[0] = f & 0xffff;\n    for (let i = 1; i < 8; i++) {\n      f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n      h[i] = f & 0xffff;\n    }\n  }\n  update(data: Input): this {\n    assert.exists(this);\n    const { buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input\n      if (take === blockLen) {\n        for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(buffer, 0, false);\n        this.pos = 0;\n      }\n    }\n    return this;\n  }\n  destroy() {\n    this.h.fill(0);\n    this.r.fill(0);\n    this.buffer.fill(0);\n    this.pad.fill(0);\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.output(out, this);\n    this.finished = true;\n    const { buffer, h } = this;\n    let { pos } = this;\n    if (pos) {\n      buffer[pos++] = 1;\n      // buffer.subarray(pos).fill(0);\n      for (; pos < 16; pos++) buffer[pos] = 0;\n      this.process(buffer, 0, true);\n    }\n    this.finalize();\n    let opos = 0;\n    for (let i = 0; i < 8; i++) {\n      out[opos++] = h[i] >>> 0;\n      out[opos++] = h[i] >>> 8;\n    }\n    return out;\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nexport function wrapConstructorWithKey<H extends Hash<H>>(hashCons: (key: Input) => Hash<H>) {\n  const hashC = (msg: Input, key: Input): Uint8Array => hashCons(key).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(32));\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input) => hashCons(key);\n  return hashC;\n}\n\nexport const poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n", "// Basic utils for salsa-like ciphers\n// Check out _micro.ts for descriptive documentation.\nimport assert from './_assert.js';\nimport { u32, utf8ToBytes, checkOpts } from './utils.js';\n\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- Original papers don't allow mutating counters\n- Counter overflow is undefined: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n- 3rd-party library stablelib implementation uses an approach where you can provide\n  nonce and counter instead of just nonce - and it will re-use it\n- We could have did something similar, but ChaCha has different counter position\n  (counter | nonce), which is not composable with XChaCha, because full counter\n  is (nonce16 | counter | nonce16). Stablelib doesn't support in-place counter for XChaCha.\n- We could separate nonce & counter and provide separate API for counter re-use, but\n  there are different counter sizes depending on an algorithm.\n- Salsa & ChaCha also differ in structures of key / sigma:\n\n    salsa:     c0 | k(4) | c1 | nonce(2) | ctr(2) | c2 | k(4) | c4\n    chacha:    c(4) | k(8) | ctr(1) | nonce(3)\n    chachaDJB: c(4) | k(8) | ctr(2) | nonce(2)\n- Creating function such as `setSalsaState(key, nonce, sigma, data)` won't work,\n  because we can't re-use counter array\n- 32-bit nonce is `2 ** 32 * 64` = 256GB with 32-bit counter\n- JS does not allow UintArrays bigger than 4GB, so supporting 64-bit counters doesn't matter\n\nStructure is as following:\n\nkey=16 -> sigma16, k=key|key\nkey=32 -> sigma32, k=key\n\nnonces:\nsalsa20:      8   (8-byte counter)\nchacha20djb:  8   (8-byte counter)\nchacha20tls:  12  (4-byte counter)\nxsalsa:       24  (16 -> hsalsa, 8 -> old nonce)\nxchacha:      24  (16 -> hchacha, 8 -> old nonce)\n\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\nUse the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n*/\n\nconst sigma16 = utf8ToBytes('expand 16-byte k');\nconst sigma32 = utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n\nexport type SalsaOpts = {\n  core: (\n    c: Uint32Array,\n    key: Uint32Array,\n    nonce: Uint32Array,\n    out: Uint32Array,\n    counter: number,\n    rounds?: number\n  ) => void;\n  rounds?: number;\n  counterRight?: boolean; // counterRight ? nonce | counter : counter | nonce;\n  counterLen?: number;\n  blockLen?: number; // NOTE: not tested with different blockLens!\n  allow128bitKeys?: boolean; // Original salsa/chacha allows these, but not tested!\n  extendNonceFn?: (c: Uint32Array, key: Uint8Array, src: Uint8Array, dst: Uint8Array) => Uint8Array;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nconst isAligned32 = (b: Uint8Array) => !(b.byteOffset % 4);\n\nexport const salsaBasic = (opts: SalsaOpts) => {\n  const { core, rounds, counterRight, counterLen, allow128bitKeys, extendNonceFn, blockLen } =\n    checkOpts(\n      { rounds: 20, counterRight: false, counterLen: 8, allow128bitKeys: true, blockLen: 64 },\n      opts\n    );\n  assert.number(counterLen);\n  assert.number(rounds);\n  assert.number(blockLen);\n  assert.bool(counterRight);\n  assert.bool(allow128bitKeys);\n  const blockLen32 = blockLen / 4;\n  if (blockLen % 4 !== 0) throw new Error('Salsa/ChaCha: blockLen must be aligned to 4 bytes');\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    assert.bytes(key);\n    assert.bytes(nonce);\n    assert.bytes(data);\n    if (!output) output = new Uint8Array(data.length);\n    assert.bytes(output);\n    assert.number(counter);\n    // > new Uint32Array([2**32])\n    // Uint32Array(1) [ 0 ]\n    // > new Uint32Array([2**32-1])\n    // Uint32Array(1) [ 4294967295 ]\n    if (counter < 0 || counter >= 2 ** 32 - 1) throw new Error('Salsa/ChaCha: counter overflow');\n    if (output.length < data.length) {\n      throw new Error(\n        `Salsa/ChaCha: output (${output.length}) is shorter than data (${data.length})`\n      );\n    }\n    const toClean = [];\n    let k, sigma;\n    // Handle 128 byte keys\n    if (key.length === 32) {\n      k = key;\n      sigma = sigma32_32;\n    } else if (key.length === 16 && allow128bitKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${key.length}`);\n    // Handle extended nonce (HChaCha/HSalsa)\n    if (extendNonceFn) {\n      if (nonce.length <= 16)\n        throw new Error(`Salsa/ChaCha: extended nonce must be bigger than 16 bytes`);\n      k = extendNonceFn(sigma, k, nonce.subarray(0, 16), new Uint8Array(32));\n      toClean.push(k);\n      nonce = nonce.subarray(16);\n    }\n    // Handle nonce counter\n    const nonceLen = 16 - counterLen;\n    if (nonce.length !== nonceLen)\n      throw new Error(`Salsa/ChaCha: nonce must be ${nonceLen} or 16 bytes`);\n    // Pad counter when nonce is 64 bit\n    if (nonceLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      toClean.push((nonce = nc));\n    }\n    // Counter positions\n    const block = new Uint8Array(blockLen);\n    // Cast to Uint32Array for speed\n    const b32 = u32(block);\n    const k32 = u32(k);\n    const n32 = u32(nonce);\n    // Make sure that buffers aligned to 4 bytes\n    const d32 = isAligned32(data) && u32(data);\n    const o32 = isAligned32(output) && u32(output);\n    toClean.push(b32);\n    const len = data.length;\n    for (let pos = 0, ctr = counter; pos < len; ctr++) {\n      core(sigma, k32, n32, b32, ctr, rounds);\n      if (ctr >= 2 ** 32 - 1) throw new Error('Salsa/ChaCha: counter overflow');\n      const take = Math.min(blockLen, len - pos);\n      // full block && aligned to 4 bytes\n      if (take === blockLen && o32 && d32) {\n        const pos32 = pos / 4;\n        if (pos % 4 !== 0) throw new Error('Salsa/ChaCha: invalid block position');\n        for (let j = 0; j < blockLen32; j++) o32[pos32 + j] = d32[pos32 + j] ^ b32[j];\n        pos += blockLen;\n        continue;\n      }\n      for (let j = 0; j < take; j++) output[pos + j] = data[pos + j] ^ block[j];\n      pos += take;\n    }\n    for (let i = 0; i < toClean.length; i++) toClean[i].fill(0);\n    return output;\n  };\n};\n", "import { Cipher, createView, ensureBytes, equalBytes, setBigUint64, u32 } from './utils.js';\nimport { poly1305 } from './_poly1305.js';\nimport { salsaBasic } from './_salsa.js';\n\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n\n// Left rotate for uint32\nconst rotl = (a: number, b: number) => (a << b) | (a >>> (32 - b));\n\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(\n  c: Uint32Array, k: Uint32Array, n: Uint32Array, out: Uint32Array, cnt: number, rounds = 20\n): void {\n  let y00 = c[0], y01 = c[1], y02 = c[2], y03 = c[3]; // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n  let y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3]; // Key      Key     Key     Key\n  let y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7]; // Key      Key     Key     Key\n  let y12 = cnt,  y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n  // Save state to temporary variables\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  // Main loop\n  for (let i = 0; i < rounds; i += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  // Write output\n  let oi = 0;\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(\n  c: Uint32Array, key: Uint8Array, src: Uint8Array, out: Uint8Array\n): Uint8Array {\n  const k32 = u32(key);\n  const i32 = u32(src);\n  const o32 = u32(out);\n  let x00 = c[0],   x01 = c[1],   x02 = c[2],   x03 = c[3];\n  let x04 = k32[0], x05 = k32[1], x06 = k32[2], x07 = k32[3];\n  let x08 = k32[4], x09 = k32[5], x10 = k32[6], x11 = k32[7]\n  let x12 = i32[0], x13 = i32[1], x14 = i32[2], x15 = i32[3];\n   for (let i = 0; i < 20; i += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  o32[0] = x00;\n  o32[1] = x01;\n  o32[2] = x02;\n  o32[3] = x03;\n  o32[4] = x12;\n  o32[5] = x13;\n  o32[6] = x14;\n  o32[7] = x15;\n  return out;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexport const chacha20orig = /* @__PURE__ */ salsaBasic({\n  core: chachaCore,\n  counterRight: false,\n  counterLen: 8,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20 = /* @__PURE__ */ salsaBasic({\n  core: chachaCore,\n  counterRight: false,\n  counterLen: 4,\n  allow128bitKeys: false,\n});\n\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexport const xchacha20 = /* @__PURE__ */ salsaBasic({\n  core: chachaCore,\n  counterRight: false,\n  counterLen: 8,\n  extendNonceFn: hchacha,\n  allow128bitKeys: false,\n});\n\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexport const chacha8 = /* @__PURE__ */ salsaBasic({\n  core: chachaCore,\n  counterRight: false,\n  counterLen: 4,\n  rounds: 8,\n});\n\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexport const chacha12 = /* @__PURE__ */ salsaBasic({\n  core: chachaCore,\n  counterRight: false,\n  counterLen: 4,\n  rounds: 12,\n});\n\nconst ZERO = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h: ReturnType<typeof poly1305.create>, msg: Uint8Array) => {\n  h.update(msg);\n  const left = msg.length % 16;\n  if (left) h.update(ZERO.subarray(left));\n};\n\nconst computeTag = (\n  fn: typeof chacha20,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n) => {\n  const authKey = fn(key, nonce, new Uint8Array(32));\n  const h = poly1305.create(authKey);\n  if (AAD) updatePadded(h, AAD);\n  updatePadded(h, data);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n  setBigUint64(view, 8, BigInt(data.length), true);\n  h.update(num);\n  const res = h.digest();\n  authKey.fill(0);\n  return res;\n};\n\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead =\n  (xorStream: typeof chacha20) =>\n  (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher => {\n    const tagLength = 16;\n    ensureBytes(key, 32);\n    ensureBytes(nonce);\n    return {\n      tagLength,\n      encrypt: (plaintext: Uint8Array, output?: Uint8Array) => {\n        const plength = plaintext.length;\n        const clength = plength + tagLength;\n        if (output) {\n          ensureBytes(output, clength);\n        } else {\n          output = new Uint8Array(clength);\n        }\n        xorStream(key, nonce, plaintext, output, 1);\n        const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n        output.set(tag, plength); // append tag\n        return output;\n      },\n      decrypt: (ciphertext: Uint8Array, output?: Uint8Array) => {\n        const clength = ciphertext.length;\n        const plength = clength - tagLength;\n        if (clength < tagLength)\n          throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n        if (output) {\n          ensureBytes(output, plength);\n        } else {\n          output = new Uint8Array(plength);\n        }\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = computeTag(xorStream, key, nonce, data, AAD);\n        if (!equalBytes(passedTag, tag)) throw new Error('invalid tag');\n        xorStream(key, nonce, data, output, 1);\n        return output;\n      },\n    };\n  };\n\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20poly1305 = /* @__PURE__ */ _poly1305_aead(chacha20);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nexport const xchacha20poly1305 = /* @__PURE__ */ _poly1305_aead(xchacha20);\n", "import assert from './_assert.js';\nimport { CHash, Input, toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash: CHash, ikm: Input, salt?: Input) {\n  assert.hash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32) {\n  assert.hash(hash);\n  assert.number(length);\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / hash.outputLen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * hash.outputLen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, hash.outputLen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Input,\n  salt: Input | undefined,\n  info: Input | undefined,\n  length: number\n) => expand(hash, extract(hash, ikm, salt), info, length);\n", "import { finishEvent } from './event.ts'\nimport { encrypt } from './nip04.ts'\nimport { Kind } from './event'\n\nexport function parseConnectionString(connectionString: string) {\n  const { pathname, searchParams } = new URL(connectionString)\n  const pubkey = pathname\n  const relay = searchParams.get('relay')\n  const secret = searchParams.get('secret')\n\n  if (!pubkey || !relay || !secret) {\n    throw new Error('invalid connection string')\n  }\n\n  return { pubkey, relay, secret }\n}\n\nexport async function makeNwcRequestEvent({\n  pubkey,\n  secret,\n  invoice,\n}: {\n  pubkey: string\n  secret: string\n  invoice: string\n}) {\n  const content = {\n    method: 'pay_invoice',\n    params: {\n      invoice,\n    },\n  }\n  const encryptedContent = await encrypt(secret, pubkey, JSON.stringify(content))\n  const eventTemplate = {\n    kind: Kind.NwcRequest,\n    created_at: Math.round(Date.now() / 1000),\n    content: encryptedContent,\n    tags: [['p', pubkey]],\n  }\n\n  return finishEvent(eventTemplate, secret)\n}\n", "import { bech32 } from '@scure/base'\n\nimport { Kind, validateEvent, verifySignature, type Event, type EventTemplate } from './event.ts'\nimport { utf8Decoder } from './utils.ts'\n\nvar _fetch: any\n\ntry {\n  _fetch = fetch\n} catch {}\n\nexport function useFetchImplementation(fetchImplementation: any) {\n  _fetch = fetchImplementation\n}\n\nexport async function getZapEndpoint(metadata: Event<Kind.Metadata>): Promise<null | string> {\n  try {\n    let lnurl: string = ''\n    let { lud06, lud16 } = JSON.parse(metadata.content)\n    if (lud06) {\n      let { words } = bech32.decode(lud06, 1000)\n      let data = bech32.fromWords(words)\n      lnurl = utf8Decoder.decode(data)\n    } else if (lud16) {\n      let [name, domain] = lud16.split('@')\n      lnurl = `https://${domain}/.well-known/lnurlp/${name}`\n    } else {\n      return null\n    }\n\n    let res = await _fetch(lnurl)\n    let body = await res.json()\n\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback\n    }\n  } catch (err) {\n    /*-*/\n  }\n\n  return null\n}\n\nexport function makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = '',\n}: {\n  profile: string\n  event: string | null\n  amount: number\n  comment: string\n  relays: string[]\n}): EventTemplate<Kind.ZapRequest> {\n  if (!amount) throw new Error('amount not given')\n  if (!profile) throw new Error('profile not given')\n\n  let zr: EventTemplate<Kind.ZapRequest> = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1000),\n    content: comment,\n    tags: [\n      ['p', profile],\n      ['amount', amount.toString()],\n      ['relays', ...relays],\n    ],\n  }\n\n  if (event) {\n    zr.tags.push(['e', event])\n  }\n\n  return zr\n}\n\nexport function validateZapRequest(zapRequestString: string): string | null {\n  let zapRequest: Event\n\n  try {\n    zapRequest = JSON.parse(zapRequestString)\n  } catch (err) {\n    return 'Invalid zap request JSON.'\n  }\n\n  if (!validateEvent(zapRequest)) return 'Zap request is not a valid Nostr event.'\n\n  if (!verifySignature(zapRequest)) return 'Invalid signature on zap request.'\n\n  let p = zapRequest.tags.find(([t, v]) => t === 'p' && v)\n  if (!p) return \"Zap request doesn't have a 'p' tag.\"\n  if (!p[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'p' tag is not valid hex.\"\n\n  let e = zapRequest.tags.find(([t, v]) => t === 'e' && v)\n  if (e && !e[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'e' tag is not valid hex.\"\n\n  let relays = zapRequest.tags.find(([t, v]) => t === 'relays' && v)\n  if (!relays) return \"Zap request doesn't have a 'relays' tag.\"\n\n  return null\n}\n\nexport function makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt,\n}: {\n  zapRequest: string\n  preimage?: string\n  bolt11: string\n  paidAt: Date\n}): EventTemplate<Kind.Zap> {\n  let zr: Event<Kind.ZapRequest> = JSON.parse(zapRequest)\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === 'e' || t === 'p' || t === 'a')\n\n  let zap: EventTemplate<Kind.Zap> = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1000),\n    content: '',\n    tags: [...tagsFromZapRequest, ['bolt11', bolt11], ['description', zapRequest]],\n  }\n\n  if (preimage) {\n    zap.tags.push(['preimage', preimage])\n  }\n\n  return zap\n}\n", "import { base64 } from '@scure/base'\nimport { Event, EventTemplate, Kind, getBlankEvent, verifySignature } from './event'\nimport { utf8Decoder, utf8Encoder } from './utils'\n\nconst _authorizationScheme = 'Nostr '\n\n/**\n * Generate token for NIP-98 flow.\n *\n * @example\n * const sign = window.nostr.signEvent\n * await nip98.getToken('https://example.com/login', 'post', (e) => sign(e), true)\n */\nexport async function getToken(\n  loginUrl: string,\n  httpMethod: string,\n  sign: <K extends number = number>(e: EventTemplate<K>) => Promise<Event<K>> | Event<K>,\n  includeAuthorizationScheme: boolean = false,\n): Promise<string> {\n  if (!loginUrl || !httpMethod) throw new Error('Missing loginUrl or httpMethod')\n\n  const event = getBlankEvent(Kind.HttpAuth)\n\n  event.tags = [\n    ['u', loginUrl],\n    ['method', httpMethod],\n  ]\n  event.created_at = Math.round(new Date().getTime() / 1000)\n\n  const signedEvent = await sign(event)\n\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : ''\n  return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)))\n}\n\n/**\n * Validate token for NIP-98 flow.\n *\n * @example\n * await nip98.validateToken('Nostr base64token', 'https://example.com/login', 'post')\n */\nexport async function validateToken(token: string, url: string, method: string): Promise<boolean> {\n  const event = await unpackEventFromToken(token).catch(error => {\n    throw error\n  })\n  const valid = await validateEvent(event, url, method).catch(error => {\n    throw error\n  })\n\n  return valid\n}\n\nexport async function unpackEventFromToken(token: string): Promise<Event> {\n  if (!token) {\n    throw new Error('Missing token')\n  }\n  token = token.replace(_authorizationScheme, '')\n\n  const eventB64 = utf8Decoder.decode(base64.decode(token))\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith('{')) {\n    throw new Error('Invalid token')\n  }\n\n  const event = JSON.parse(eventB64) as Event\n\n  return event\n}\n\nexport async function validateEvent(event: Event, url: string, method: string): Promise<boolean> {\n  if (!event) {\n    throw new Error('Invalid nostr event')\n  }\n  if (!verifySignature(event)) {\n    throw new Error('Invalid nostr event, signature invalid')\n  }\n  if (event.kind !== Kind.HttpAuth) {\n    throw new Error('Invalid nostr event, kind invalid')\n  }\n\n  if (!event.created_at) {\n    throw new Error('Invalid nostr event, created_at invalid')\n  }\n\n  // Event must be less than 60 seconds old\n  if (Math.round(new Date().getTime() / 1000) - event.created_at > 60) {\n    throw new Error('Invalid nostr event, expired')\n  }\n\n  const urlTag = event.tags.find(t => t[0] === 'u')\n  if (urlTag?.length !== 1 && urlTag?.[1] !== url) {\n    throw new Error('Invalid nostr event, url tag invalid')\n  }\n\n  const methodTag = event.tags.find(t => t[0] === 'method')\n  if (methodTag?.length !== 1 && methodTag?.[1].toLowerCase() !== method.toLowerCase()) {\n    throw new Error('Invalid nostr event, method tag invalid')\n  }\n\n  return true\n}\n"],
  "mappings": "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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["utils_exports", "hash", "crypto", "bytes", "hex", "crypto", "isLE", "_32n", "bytesToHex", "concatBytes", "hexToBytes", "utf8ToBytes", "u8a", "hexes", "bytesToHex", "bytes", "hex", "hexToBytes", "concatBytes", "utf8ToBytes", "_0n", "_1n", "_2n", "number", "gcd", "Fp", "ge", "f", "_0n", "_1n", "bitLen", "isLE", "_0n", "f", "_1n", "bytes", "hash", "isLE", "_1n", "_0n", "_1n", "f", "Fp", "hex", "s", "_0n", "_1n", "_2n", "_3n", "_4n", "toBytes", "concatBytes", "bytes", "bytesToHex", "Point", "f", "a", "modN", "number", "hexToBytes", "utils", "getPublicKey", "hash", "randomBytes", "r", "hash", "hash", "_1n", "_2n", "_3n", "_0n", "concatBytes", "utils_exports", "Kind", "hash", "f", "id", "resolve", "reject", "challenge", "listeners", "filters", "opts", "batchKey", "relays", "decode", "alphabet", "padding", "bytes", "checksum", "sha256", "_words", "number", "hex", "hash", "salt", "wordlist", "normalize", "normalize", "Point", "base58check", "bytes", "hash", "hex", "parse", "parse", "tag", "useFetchImplementation", "_fetch", "useFetchImplementation", "challenge", "decrypt", "encrypt", "utils", "u8a", "isLE", "utf8ToBytes", "toBytes", "utf8ToBytes", "u8a", "isPlainObject", "checkOpts", "ensureBytes", "equalBytes", "number", "bool", "bytes", "hash", "exists", "output", "assert", "number", "bool", "bytes", "hash", "exists", "output", "assert_default", "toBytes", "ensureBytes", "f", "assert_default", "utf8ToBytes", "checkOpts", "assert_default", "output", "rotl", "hash", "salt", "HMAC", "utils", "salt", "encrypt", "ensureBytes", "decrypt", "equalBytes", "useFetchImplementation", "_fetch", "useFetchImplementation", "validateEvent", "validateEvent"]
}
